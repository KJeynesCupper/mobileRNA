#' Overlap genome annotation file information with sRNA-seq data 
#'
#' Based on genomic coordinates, assign sRNA clusters with matching annotation 
#' information. This function can be used to find the origins of sRNA clusters, 
#' and identify whether they overlap with genes or repetitive regions. An 
#' additional buffer region at the start/end of the gene is added improve hits, 
#' and align with the assumptions about promoter regions. 
#'
#' @details The function merges an annotation (GFF format) file with
#' the sRNA data set based on the chromosome, start and end coordinates. 
#' 
#' It is important that any alteration which were made to the genome reference
#' (FASTA), such as alterations to the chromosome name, must be carried forth
#' to the genome annotation file. If alterations were made to the reference
#' genome using the [mobileRNA::RNAmergeGenomes()] function, alteration
#' inline with these can be accomplished using the
#' [mobileRNA::RNAmergeAnnotations()] function.
#'
#' @param data data.frame; originally generated by [mobileRNA::RNAimport()] or 
#' containing  `chr`, `start` and `end` columns. 
#'
#' @param annotation path; URL, connection or GFFFile object. A genome
#' reference annotation file (.gff/.gff1/.gff2/.gff3).
#'
#' @param match character; must be either  "within" or "genes". Where 
#' "within" will return matches where the clusters can be found within any 
#' annotation, while "genes" will return matches where the clusters can be found 
#' within only genes. 
#' 
#' @param bufferRegion numeric; a buffer region in base-pairs to extend the 
#' start and end coordinates upstream and downstream respectively. 
#' 
#' 
#'@return Adds additional columns from the GFF containing information which
#'overlaps any sRNA cluster loci. These columns represent the standard columns
#'in a GFF file. 
#'
#'
#'
#' @export
#' @importFrom rtracklayer "import"
#' @importFrom GenomicRanges "GRanges"
#' @importFrom GenomicRanges "findOverlaps"
#' @importFrom S4Vectors "queryHits"
#' @importFrom S4Vectors "subjectHits"
#' @importFrom dplyr "mutate"
#' @importFrom rlang "sym"
#' @importFrom dplyr "select_if"
#' @importFrom IRanges "IRanges"
#' @importFrom S4Vectors "mcols" 
#' @importFrom IRanges "ranges"
#' @importFrom S4Vectors "elementMetadata"
#' @importFrom GenomeInfoDb "seqnames"
#' @examples
#'  # load data 
#' data("sRNA_data")
#'
#' attributes_df <- RNAattributes(data = sRNA_data,
#'                     annotation = system.file("extdata",
#'                     "reduced_chr2_Tomato.gff", package="mobileRNA"),
#'                     match = "genes")
#'
RNAattributes <- function(data, annotation, match = c("within", "genes"),
                          bufferRegion = 1000){
  if (base::missing(data) || nrow(data) == 0) {
    stop("data is missing. data must be an object of class matrix, data.frame, 
           DataFrame")
  }
  
  if (missing(annotation) || is.null(annotation) ) {
    stop("annotation parameter is missing or empty.")
  }
  
  if (is.character(annotation) || file.exists(annotation)|| 
      !grepl("\\.(gff|gff1|gff2|gff3)$",annotation)) {
    annotation <- suppressMessages(rtracklayer::import(annotation)) 
  } else 
    if(!methods::is(annotation, "GRanges")){
      stop("The annotation does not exist, must either be a path or GRange object.") 
    }
  
  if(match == "within"){
    features_gr <-  annotation
    # convert data to granges 
    data_gr <- GenomicRanges::GRanges(data$chr,
                  ranges = IRanges::IRanges(start = as.numeric(data$start), end = as.numeric(data$end))
    )
    # Find overlaps between genomic loci and adjusted GRanges
    overlaps <- suppressWarnings(GenomicRanges::findOverlaps(data_gr, features_gr)) 
    
    # Get the indices of overlapping genomic loci ie row number 
    queryHits_ot <- S4Vectors::queryHits(overlaps)
    subjectHits_ot <- S4Vectors::subjectHits(overlaps)
    
    
    # convert to dataframe 
    features_gr_df <- as.data.frame(features_gr)
    # add columns to data 
    add_cols <- colnames(features_gr_df) 
    col_diff <- setdiff(add_cols, colnames(data))
    rm_extra <- c("seqnames", "width","strand","source", "score", "phase")
    col_diff <- col_diff[!col_diff %in% rm_extra]
    
    data[,col_diff] <- NA
    if(length(subjectHits_ot) == 0 ){
      stop("No genomic features matched the sRNA clusters")
    }
    for (i in 1:length(subjectHits_ot)) {
      row_index <- subjectHits_ot[i]
      row_vals <- features_gr_df[row_index, ]
      row_vals<- row_vals[,col_diff] # only extra columns. 
      for (j in names(row_vals)) {
        if (j %in% names(data[queryHits_ot[i],])) {
          data[queryHits_ot[i],] <- data[queryHits_ot[i],] %>%
            dplyr::mutate(!!j := ifelse(is.na(!!rlang::sym(j)), row_vals[[j]], 
                                        !!rlang::sym(j)))
        }
      }
    }
    
    # remove columsn with only NAs
    data <- data  %>% dplyr::select_if(~sum(!is.na(.)) > 0)
  }
  
  if(match == "genes"){
    # find clumn with 
    meta <- as.data.frame(S4Vectors::mcols(annotation))
    # select column with cells contain "gene", but if they contain "gene" then nothing else. 
    gene_columns <- which(sapply(meta, function(x) any(grepl("^gene$", x))))
    gene_col_name <- names(meta)[gene_columns]
    # select genes
    genes <- annotation[S4Vectors::elementMetadata(annotation)[,gene_col_name] == "gene"]
    # amend ranges
    adjusted_ranges <- IRanges::IRanges(
      start = as.data.frame(IRanges::ranges(genes))$start - bufferRegion,
      end = as.data.frame(IRanges::ranges(genes))$end + bufferRegion
    )
    
    #add ranges to genes info  
    adjusted_grange <- GenomicRanges::GRanges(
      GenomeInfoDb::seqnames(genes),
      ranges = adjusted_ranges,
      metadata = S4Vectors::mcols(genes)
    )
    
    # convert data to granges 
    data_gr <- GenomicRanges::GRanges(
      seqnames = data$chr,
      ranges = IRanges::IRanges(start = as.numeric(data$start), end = as.numeric(data$end))
    )
    
    # Find overlaps between genomic loci and adjusted GRanges
    overlaps <- suppressWarnings(GenomicRanges::findOverlaps(data_gr, adjusted_grange)) 
    
    # Get the indices of overlapping genomic loci ie row number 
    queryHits_ot <- S4Vectors::queryHits(overlaps)
    subjectHits_ot <- S4Vectors::subjectHits(overlaps)
    
    
    # convert to dataframe 
    adjusted_grange_df <- as.data.frame(adjusted_grange)
    # converion adds metadeta to metadatcols 
    names(adjusted_grange_df) <- sub('^metadata.', '',names(adjusted_grange_df))
    # add columns to data 
    add_cols <- colnames(adjusted_grange_df) 
    col_diff <- setdiff(add_cols, colnames(data))
    rm_extra <- c("seqnames", "width","strand","source", "score", "phase")
    col_diff <- col_diff[!col_diff %in% rm_extra]
    data[,col_diff] <- NA
    if(length(subjectHits_ot) == 0 ){
      stop("No genomic features matched the sRNA clusters")
    }
    
    for (i in 1:length(subjectHits_ot)) {
      row_index <- subjectHits_ot[i]
      row_vals <- adjusted_grange_df[row_index, ]
      row_vals<- row_vals[,col_diff] # only extra columns. 
      
      for (j in names(row_vals)) {
        if (j %in% names(data[queryHits_ot[i],])) {
          data[queryHits_ot[i],] <- data[queryHits_ot[i],] %>%
            dplyr::mutate(!!j := ifelse(is.na(!!rlang::sym(j)), row_vals[[j]], 
                                        !!rlang::sym(j)))
        }
      }
    }
    
    # remove columns with na
    data <- data[,colSums(is.na(data))<nrow(data)]
    
  }
  return(data)
}
