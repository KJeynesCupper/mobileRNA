#' Heatmap of log-transformed normalization data
#'
#' @description Undertakes RPM/FPKM normalisation using a pseudocount and 
#' transforms the data using log-scale, to enable visualization of the 
#' differences and patterns in expression across samples using a heatmap. 
#'
#'
#' @param data data.frame; originally generated by [mobileRNA::RNAimport()] 
#' 
#' @param value character; either `FPKM` or `RPM` - represents values to plot
#'
#' @param colours character; colors. Default is 
#'` grDevices::colorRampPalette(RColorBrewer::brewer.pal(9, "Blues"))(100) `
#'
#' @param pseudocount numeric; pseudocount, default is `1e-6`
#' 
#' @param cluster logical; include hierarchical clustering when default 
#' `cluster= TRUE`
#' 
#' @param scale character; indicating whether the values should be centered & 
#' scaled in either the row direction or the column direction, or none. 
#' Respective options are "row", "column" & "none". Default, `scale="none"`.
#' @param clustering_method character; clustering method used. Accepts the same 
#' values as hclust. Default `clustering_method= "complete"`
#' @param row.names logical; indicated whether to include cluster names as 
#' rownames. Default `row.names=TRUE`
#' 
#' @param border.color border colour, default is no border, NA. 
#'
#' @details Undertakes FPKM/RPM normalisation using a pseudocount and then 
#' transforms the normalised-RPM data using log-scale. 
#' 
#' This function expects to receive a dataframe containing FPKM/RPM data from 
#' sRNA-seq studies. This function employs the use of a pseudocount during 
#' normalisation as the function is expected to be used when identifying mobile 
#' sRNAs in a chimeric system. In such system, it is expected that control 
#' replicates will contain zero values for the candidate mobile sRNA clusters. 
#' 
#' 
#'@return Produces a list of objects, including the plot. 
#'
#' @examples
#'data("sRNA_data")
#'
#' # vector of control names
#' controls <- c("selfgraft_1", "selfgraft_2" , "selfgraft_3")
#'
#' # Locate potentially mobile sRNA clusters associated to tomato, no
#' # statistical analysis
#' sRNA_data_mobile <- RNAmobile(input = "sRNA", data =  sRNA_data,
#' controls = controls, genome.ID = "B_", task = "keep", statistical = FALSE)
#'
#' # plot heatmap of potential mobile sRNAs
#'  p1 <-  plotHeatmap(sRNA_data_mobile, row.names = FALSE)
#'
#'
#'
#'
#' @export
#' @importFrom dplyr %>%
#' @importFrom dplyr select
#' @importFrom tidyselect starts_with
#' @importFrom pheatmap pheatmap
#' @importFrom grDevices colorRampPalette
#' @importFrom RColorBrewer brewer.pal
plotHeatmap <- function (data, value = "RPM", pseudocount = 1e-6, 
                         colours = grDevices::colorRampPalette(RColorBrewer::brewer.pal(9, "Blues"))(100) ,
                         cluster = TRUE, scale = "none", 
                         clustering_method = "complete", 
                         row.names = TRUE,
                         border.color = NA) {
  if (base::missing(data) || !base::inherits(data, c("matrix","data.frame", 
                                                     "DataFrame"))) {
    stop("data must be an object of class matrix, data.frame, DataFrame.
          See ?plotHeatmap for more information.")
  }
  allowed_styles <- c("RPM", "FPKM")
  if (!value %in% allowed_styles) {
    stop("value parameter must be one of 'RPM', or 'FPKM'.")
  }
  if (value == "RPM" && any(grepl(paste0("^", "RPM_"), colnames(data)))) {
    select_data <- data %>% dplyr::select(tidyselect::starts_with("RPM_"))
    names(select_data) <- sub('^RPM_', '', names(select_data))
  } else 
    if (value == "FPKM" && any(grepl(paste0("^", "FPKM_"), colnames(data)))) {
    select_data <- data %>% dplyr::select(tidyselect::starts_with("FPKM"))
    names(select_data) <- sub('^FPKM', '', names(select_data))
   } else {
    stop("data must contain columns containing either FPKM, or  RPM data 
          columns depending on the 'value' parameter.")
  }
  rownames(select_data) <- data$clusterID # remove cluster with no counts 
  select_data <- select_data[rowSums(select_data[])>0,]
  total_reads_per_sample <- colSums(select_data)   # RPM normalization with pseudocount addition
  rpm_matrix <- (select_data / (total_reads_per_sample + pseudocount)) * 1e6
  log_rpm_matrix <- log2(rpm_matrix + 1)   # log transform. 
  data_rownames <- data$Cluster  # add cluster names
  rownames(log_rpm_matrix) <- data_rownames   # add row names 
  if(cluster == FALSE){
    p1 <- pheatmap::pheatmap(log_rpm_matrix, scale = scale,cluster_rows = FALSE, 
                             cluster_cols = FALSE, show_row_dendrogram = FALSE, 
                             show_col_dendrogram = FALSE, color = colours,
                             show_rownames = row.names, 
                             border_color = border.color,fontsize_row = 10,            
                             fontsize_col = 10)
  } else {
    p1 <- pheatmap::pheatmap(log_rpm_matrix,scale = scale,               
                             clustering_method = clustering_method,  
                             color = colours,show_rownames = row.names,
                             fontsize_row = 10, fontsize_col = 10, 
                             border_color = border.color,cluster_cols = FALSE)
  }
  out <- list(plot = p1, data = log_rpm_matrix)
  return(out)
}
