#' Define the sRNA dicer consensus for each dicer-derived sRNA cluster
#'
#' @description Using the data, the function uses the supplied dataframe and
#' adds an additional column stating the consensus sRNA class for each
#' dicer-derived cluster.
#'
#' @details
#' The function calculates the consensus sRNA class. Changes in parameter 
#' settings will yield varying results. 
#'
#' When working with a chimeric system, for example interspecific grafting, 
#' mapping errors can easily be recognised and eliminated. Here, these can be 
#' eliminated by supplying some extra parameter information. State 
#' `chimeric=TRUE` and supply the chromosome identifier of the foreign genome 
#' (ie. not the tissue sample genotype, but the genotype from which any 
#' potential mobile molecules could be traveling from) to the `genome.ID` 
#' parameter & the control condition samples names to the `controls` parameter. 
#' 
#' When ties.method = "random", as per default, ties are broken at random. 
#' In this case, the determination of a tie assumes that the entries are 
#' probabilities: there is a relative tolerance of 1e-5, relative to the 
#' largest (in magnitude, omitting infinity) entry in the row.
#' 
#' When ties.method = "exclude", ties between sRNA classification are ruled as 
#' unclassified ("N"). 
#' 
#' To remove excess data noise, `tidy=TRUE` can be used to removed unclassified 
#' ("N") sRNA clusters, resulting in a reduced dataset size. 
#' 
#' @param data data.frame; originally generated by [mobileRNA::RNAimport()].
#'
#' @param conditions character; vector containing sample replicate names. When 
#' supplied, the data from the named replicates will be the only ones used to 
#' calculate the dicer-derived dicercall consensus for each sRNA cluster. Each 
#' string should represent a sample name present in the dataframe supplied to
#' the `data` argument.
#'
#' @param tidy logical; tidy-up data by removing sRNA clusters with an unknown 
#' or unclassified result. Default setting \code{tidy=TRUE}, removes excess 
#' background noise. 
#'  
#' @param ties.method character; string specifying how ties are handled, choose
#' either "exclude" or "random". When using `random`, if there is a tie one of 
#' the classes will be choose at random. While, when using `exclude` if there is 
#' a tie the class is set to undefined, however, if there is a tie between a 
#' undefined and a known class, the known class takes president (eg 3x24-nt and
#' 3xN-nt, then it will be classed as 24nt). Default setting 
#' `ties.method="exclude"`. 
#' 
#' 
#'@param chimeric logical; state whether system is chimeric: contains multiple 
#'genomes/genotypes. 
#'
#'@param controls character; vector of control condition sample names. 
#'
#'@param genome.ID character; chromosome identifier of foreign genome in 
#'chimeric system.
#'
#'@return A data frame containing all existing columns in the input data object,
#'plus, two additional columns of data: 
#'
#'The first column, `DicerCounts` contains the number of replicates which 
#'contributed to defining the dicer-derived sRNA class. This can be 
#'utilised within the \code{RNAmobile} function as a threshold parameter. 
#'While, utilising `exclude` ties methods, the `DicerCounts` value for a tie 
#'will be 0 as no consensus classification was concluded. While, if the majority 
#' of replicates contributed unclassified for a cluster, the `DicerCounts` value 
#' represents the number of replicates which which contributed to the 
#' unclassified consensus in `DicerConsensus`. 
#' 
#'
#'The second, labeled `DicerConsensus` states the consensus sRNA class between 
#'nucleotides in length or "N" if unclassified. 
#'
#'
#' @examples
#'  # load data 
#'  data("sRNA_data")
#'
#' # define consensus sRNA classes.
#' conditions <- c("heterograft_1", "heterograft_2", "heterograft_3")
#'
#' # Run function to define sRNA class for each cluster.
#' sRNA_data_consensus <- RNAdicercall(data = sRNA_data,
#'                                   conditions = conditions,
#'                                   tidy=TRUE)
#'
#' @export
#' @importFrom dplyr "%>%"
#' @importFrom dplyr "mutate"
#' @importFrom dplyr "filter"
#' @importFrom tidyr "replace_na"
RNAdicercall <- function(data, conditions = NULL, ties.method = NULL, 
                         tidy = FALSE, chimeric = FALSE, controls = NULL, 
                         genome.ID = NULL) {
  if (base::missing(data)) {
    stop("data is missing. data must be an object of class matrix, data.frame, 
         DataFrame")
  }
  if (!base::inherits(data, c("matrix", "data.frame", "DataFrame"))) {
    stop("data must be an object of class matrix, data.frame, DataFrame")
  }
  if(is.null(ties.method)){
    ties.method <-  "exclude"
  }
  data[is.na(data)] <- "N"
  
  # remove mapping errors:
  if(chimeric){
    data <- .remove_mapping_errors_V2(data = data,controls = controls, 
                                      genome.ID = genome.ID)
  }
  
  class_colnames <- colnames(data)[grep("DicerCall_", colnames(data))]
  
  if (!is.null(conditions)) {
    message("Calculating consensus dicercall based on information from select 
replicates... ")
    onlyconditions <- base::unique(grep(paste(conditions, collapse = "|"), 
                                        class_colnames, value = TRUE))
  }
  else if (is.null(conditions)) {
    message("Calculating consensus dicercall based on information from all replicates... ")
    onlyconditions <- class_colnames
  }
  # unique values across the dicer call columns 
  unique_vals <- unique(unlist(data[onlyconditions]))
  # rowsum of columsn. 
  for (value in unique_vals) {
    add_col <- paste0("nt_", value)
    data[add_col] <- rowSums(data[onlyconditions] == value)
  }
  
  # search columns based on location 
  t <- grep("^nt", base::names(data))
  
  if (ties.method == "random"){
    message("The consensus dicercall will be choose at random in the case of a tie...")
    new_df <- data 
    new_df$DicerCounts <- apply(new_df[t], 1, max)
    new_df <- new_df %>% 
      dplyr::mutate(DicerConsensus = base::names(data)[t]
                    [max.col(data[t], ties.method = "random")* NA^(
                      rowSums(data[t]) ==0)]) %>%
      dplyr::mutate(DicerConsensus = tidyr::replace_na(DicerConsensus, "N")) 
    
  } else 
    if(ties.method == "exclude"){
      message("The consensus dicercall will be excluded in the case of a tie...") 
      new_df <- data
      # Initialize result vector
      result <- vector("character", nrow(new_df))
      result[] <- "N"
      dicer_counts <- vector("character", nrow(new_df))
      dicer_counts[] <- "N"
      
      # For loop to check for two matching non-zero numbers within the same row
      for (i in seq_len(nrow(new_df)) ) {
        row_values <- new_df[t][i, ]
        if(rowSums(row_values) == 0){ # if no class across reps:
          classification <- "N"
          dicer_counts_val <- length(onlyconditions)
        } 
        non_zero_values <- as.numeric(row_values[row_values != 0])
        values_table <- table(non_zero_values)
        max_value <- max(non_zero_values)
        # Check if the maximum value is duplicated
        if (!is.na(values_table[max_value]) && values_table[max_value] > 1) {
          dicer_counts_val <- 0
          classification <- "N"
        } else {
          numeric_class <- names(row_values[, row_values[1, ] > 0, 
                                            drop = FALSE])
          max_value <- max(unlist(row_values))
          if(length(numeric_class) ==  1 ){ 
            # if there is only one class
            # and if it is the max acros other results
            classification <- numeric_class
            count_max <- max.col(row_values)
            dicer_counts_val<- as.numeric(row_values[,count_max])
          } else
            if(sum(unlist(row_values) == max_value) == 1){
              count_max <- max.col(row_values)
              classification <- colnames(row_values)[count_max]
              dicer_counts_val<- as.numeric(row_values[,count_max])
            } else 
              if(length(names(row_values[, row_values[1, ] > 0]))>= 2){
                if(sum(nchar(numeric_class)) > 10){
                  # if tie between two different classes
                  dicer_counts_val <- 0
                  classification <- "N"
                } else {
                  if(sum(nchar(numeric_class)) < 10){
                    # if tie with class and unclassed
                    index_longest <- which.max(nchar(numeric_class))
                    classification <- numeric_class[index_longest]
                    dicer_counts_val <- row_values[1, classification]
                  }
                }
              } 
        }
        result[i] <- classification
        dicer_counts[i] <- dicer_counts_val
      }
      new_df$DicerCounts <- as.numeric(dicer_counts)
      new_df$DicerConsensus <- result
    } 
  # remove calulation columns 
  new_df <- new_df[, !grepl("^nt_", colnames(new_df))]
  # remove nt from output values
  new_df$DicerConsensus <- gsub("^nt_", "", new_df$DicerConsensus)
  
  if (tidy) {
    message("Removing sRNA clusters with no consensus dicercall...")
    new_df_tidy <- new_df %>% dplyr::filter(DicerConsensus != "N")
    return(new_df_tidy)
  }
  return(new_df)
}
