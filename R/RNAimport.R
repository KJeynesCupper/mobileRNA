#' Import and organise sRNAseq data sets
#'
#' @description Load and organise either sRNAseq results into a
#' single dataframe containing all experimental replicates specified where rows
#' represent either a sRNA locus or gene, respectively.
#'
#'
#' @details
#' Supply the directory to the folder storing the various sample replicate
#' folders produced by ShortStack analysis. Within each sample replicate folder,
#' there is "Result.txt". This file contains many different columns, but
#' for the analysis the columns of interest are  "Locus", "DicerCall", "Reads",
#' and "RPM" which will all be imported and loads into the new data frame.
#' Note that "Reads" will be converted to "Counts" as output of the function.
#' Locus contains the genomic locations of clusters,
#' Dicercall contains the most likely size of the cluster, Reads contains the
#' number of reads mapped to the cluster (recommended to use unique mapping,
#' hence these will be the number of uniquely mapped reads, ie, not including
#' multimapped reads). Lastly, RPM contains the Reads per Million score.
#'
#' \code{"RNAimport"} takes the results from  pre-processed sRNAseq data which
#' has been mapped and undertaken cluster analysis through ShortStack, organises
#'  into a single data frame. Each row represent an sRNA dicer-derived cluster
#'  within the analysis and columns 1 - 5 supply information on the cluster
#'  including the locus, the separated coordinates
#' (chromosome, start, end) and cluster name.
#'
#' Further columns represent data imported for each samples including DicerCall,
#' Counts and RPM. The DicerCall represents the size of most
#' abundant small RNA size based on the parameter used in ShortStack.
#' The Count column represents the number of aligned sRNA-seq reads that overlap
#' the locus. The RPM represents the reads per million.
#' For each replicate included in the analysis, these columns are labeled with
#' the type and then then name of the sample, for example, for
#' a sample called "Sample1", the information from this sample will be stored in
#' columns DicerCall_Sample1, Count_Sample1 and RPM_Sample1.
#'
#'@references ShortStack (https://github.com/MikeAxtell/ShortStack)
#'@param input string; define type of Next-Generation Sequencing dataset.
#'"sRNA" is the only valid inputs at this time.
#'
#' @param directory path; directory containing of sample folders generated by 
#' `ShortStack`
#'
#' @param samples character; vector naming samples correlating
#' to outputted folders within the `directory` path.
#' 
#'@param tidy logical; tidy-up dataframe by removing sRNA clusters 
#'where there are zero counts across all replicates.
#'
#'
#'@return A dataframe where rows represent sRNA clusters and columns represent
#'replicate information. Replicate information includes Dicercall, Counts, RPM
#'and MajorRNA sequence. Each replicate information is distinguishable as
#'the replicate name is ajoined as a prefix to each column name.
#'
#' @examples
#' \dontrun{
#'
#' # import sRNAseq data
#' df_sRNA <- RNAimport(input = "sRNA",
#'                      directory = "./analysis/sRNA_mapping_results",
#'                      samples = c("heterograft_1", "heterograft_2",
#'                      "heterograft_3","selfgraft_1" , "selfgraft_2" ,
#'                      "selfgraft_3"))
#'
#'
#'}
#'# The output of this function can be explore in the data object sRNA_data
#' data("sRNA_data")
#' head(sRNA_data)
#'
#'
#' @export
#' @importFrom data.table "data.table"
#' @importFrom data.table "setnames"
#' @importFrom utils "read.table"
#' @importFrom data.table "fread"
#' @importFrom dplyr "mutate"
#' @importFrom dplyr "across"
#' @importFrom dplyr "contains"
#' @importFrom tidyr "replace_na"
#' @importFrom data.table ":="
#' @importFrom dplyr "%>%"
#' @importFrom dplyr "filter"
#' @importFrom dplyr "if_any"
#' @importFrom dplyr "where"
#' @importFrom stats "setNames"
#' @importFrom utils "flush.console"

RNAimport <- function(input = c("sRNA"), directory, samples,
                       tidy = TRUE) {
  if (base::missing(input) || !input %in% c("sRNA")) {
    stop("Please state the data-type to the `input` paramter. Currently, only 
          `sRNA` data is accepted.")
  }
  if (base::missing(directory)) {
    stop("Please specify an accessable directory where files are stored")
  }
  if (base::missing(samples)) {
    stop("Please specify a vector storing sample names matching files")
  }
  if(input=="sRNA"){
    # LOad sample data as list of data frames, with index as file name.
    dt_list <- list()
    total_files <- length(samples)
    file_n <- 0
    for (file in samples) {
      file_n <- file_n + 1
      options(datatable.showProgress = FALSE)
      dt_list[[file]] <- data.table::fread(file.path(directory, file,
                                                  "Results.txt"),header = TRUE)
      progress_counter <- file
      progress_message <- paste0("Processing sample: ", progress_counter,
                                 "\n",
                                 "File ", file_n, " of ", total_files)
      message(sprintf("\r%s", progress_message))
      utils::flush.console()
    }
    message("Completed importation of data from directory.")
    # remove any hashtags from header - added by shortstack
    dt_list <- lapply(dt_list, function(x) setNames(x, gsub("#", "", names(x))))
    # Check each data frame in the list for the required columns
    message("Checking data content...")
    required_cols <- c("Locus", "DicerCall", "Reads", "RPM", "MajorRNA")
    for (df in dt_list) {
      if (!all(required_cols %in% colnames(df))) {
        stop("Sample data frame does not contain all required columns: ",
             paste(setdiff(required_cols, colnames(df)), ".", collapse = ", ",
                   "Make sure there is not a hashtag or similar in the header
                   line of the input file(s)"))
      }
    }
    message("Data content is correct.")
    # merge first columns to create list of loci across all samples
    loci <- lapply(dt_list, "[", , "Locus")
    loci_all <- unique(Reduce(merge,loci))
    # Define a function to update the loci with the matching values from a
    # single input dataframe
    update_locus_df <- function(dt, i) {
      # Join loci and the current input df on chromosome and coordinate range
      join_cols <- c("Locus")
      dt_match <- loci_all[dt, on = join_cols, nomatch = 0]
      # Aggregate the matching rows by chromosome, start coordinate, & end coor,
      # and compute the sum of DicerCall, Reads, and RPM values for each group
      dt_agg <- dt_match[, .(DicerCall = as.character(DicerCall),
                             Count=sum(Reads),
                             RPM = sum(RPM),
                             MajorRNA = as.character(MajorRNA)),
                         by = join_cols]
      # Rename the aggregated columns
      col_names <- paste0(c("DicerCall_", "Count_", "RPM_", "MajorRNA_"),  i)
      data.table::setnames(dt_agg, c("Locus", col_names))

      # Merge the aggregated values back into df1
      loci_all[dt_agg, on = join_cols, (col_names) := mget(col_names)]

    }
    # Update loci with the matching values from each input dataframe
    for (i in seq_len(length(dt_list))) {
      update_locus_df(dt_list[[i]], names(dt_list)[i])
    }
    # Fill in missing values with 0 or N
    ## Dicer call needs to character/factor
    loci_all <- loci_all %>%
      dplyr::mutate(dplyr::across(dplyr::contains('Count_'),
                                  ~tidyr::replace_na(.,0))) %>%
      dplyr::mutate(dplyr::across(dplyr::contains('RPM_'),
                                  ~tidyr::replace_na(.,0))) %>%
      dplyr::mutate(dplyr::across(dplyr::contains('DicerCall_'),
                                  ~tidyr::replace_na(.,"N")))%>%
      dplyr::mutate(dplyr::across(dplyr::contains('MajorRNA_'),
                                  ~tidyr::replace_na(.,"N"))) %>%
      dplyr::mutate_all(~ ifelse(. == "*", "N", .)) # remove any astriks to "N"
    # Convert loci_all back to a data.frame and return it
    res_data <- as.data.frame(loci_all)
    # Split the Locus column into three new columns
    locus_cols <- data.frame(
      chr = sapply(strsplit(res_data$Locus, split = ":"), "[[", 1),
      start = sapply(strsplit(sapply(strsplit(res_data$Locus, split = ":"),
                                     "[[", 2), split = "-"), "[[", 1),
      end = sapply(strsplit(sapply(strsplit(res_data$Locus, split = ":"),
                                   "[[", 2), split = "-"), "[[", 2)
    )
    df_final <- cbind(res_data[,1], locus_cols, res_data[, 2:ncol(res_data)])
    names(df_final)[1] <- "Locus"
    # order by chr
    df_final <- df_final[order(df_final$chr),]
    # insert cluster name
    cluster_names <-  paste0("cluster_", seq_len(nrow(df_final)) )
    df_final <- as.data.frame(append(df_final, list(Cluster = cluster_names),
                                     after = 4))
# Remove rows with no counts 
count_columns <- grep("^Count", names(df_final))
# Identify rows where all values in Count columns are zero
rows_to_remove <- apply(df_final[count_columns], 1, function(row) all(row == 0))
# Remove rows with all zero values in Count columns
df_final <- df_final[!rows_to_remove, ]   
                        
    # return values
    return(df_final)

  } 
}

