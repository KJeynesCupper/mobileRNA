#' Import and organise sRNAseq data sets
#'
#' @description Load and organise either sRNAseq results into a
#' single dataframe containing all experimental replicates specified where rows
#' represent either a sRNA locus or gene, respectively.
#'
#'
#' @details
#' The `RNAimport()` function requires the user to supply a directory path and 
#' a character vector. The path must be to the mapping/alignment output. 
#' Following the `mobileRNA` method, this path will be to the 
#' `2_alignment_results` folder produced by the [mobileRNA::sRNAmapper()] 
#' function. The `RNAimport()` function requires a vector storing the names of 
#' the replicates in the analysis. These should represent and mirror the names 
#' of the folders stored within the `2_alignment_results` folder. 
#'  
#'  Together this information allows the function to extract the information 
#'  stored in "Result.txt" files of each sample. 
#'  
#'@references ShortStack (https://github.com/MikeAxtell/ShortStack)
#'@param input string; define type of Next-Generation Sequencing dataset.
#'"sRNA" is the only valid inputs at this time.
#'
#' @param directory path; directory containing of sample folders generated by 
#' `ShortStack`
#'
#' @param samples character; vector naming samples correlating
#' to outputted folders within the `directory` path.
#' 
#'@param tidy logical; tidy-up dataframe by removing sRNA clusters 
#'where there are zero counts across all replicates.
#'
#'@param FPKM logical; calculate the FPKM for each sample
#'
#'@return A dataframe where rows represent sRNA clusters and columns represent
#'replicate information. Replicate information includes Dicercall, Counts,
#'and MajorRNA sequence. Each replicate information is distinguishable as
#'the replicate name is joined as a suffix to each column name. For example, for
#' a sample called "Sample1", the columns will include DicerCall_Sample1, 
#' Count_Sample1, MajorRNA_Sample1 and RPM_Sample1
#'
#'The breakdown of each column:
#'
#'* `Locus` : sRNA cluster locus
#'* `Chr` : Chromosome 
#'* `start` : start coordinate of cluster
#'* `end` : end coordinate of cluster
#'* `Cluster` : name of cluster 
#'* `DicerCall_` : the size in nucleotides of most abundant sRNA in the cluster
#'* `Counts_` :  number of uniquely aligned sRNA-seq reads that overlap the locus
#'* `MajorRNA_` : RNA sequence of the most abundant sRNA in the cluster
#'* `RPM_` : reads per million
#'* `FPKM_` : Fragments Per Kilobase of transcript per Million mapped reads (only if option activated)
#'
#'  
#'
#'
#' @examples
#' \dontrun{
#'
#' # import sRNAseq data
#' df_sRNA <- RNAimport(input = "sRNA",
#'                      directory = "./analysis/sRNA_mapping_results",
#'                      samples = c("heterograft_1", "heterograft_2",
#'                      "heterograft_3","selfgraft_1" , "selfgraft_2" ,
#'                      "selfgraft_3"))
#'
#'
#'}
#'# The output of this function can be explore in the data object sRNA_data
#' data("sRNA_data")
#' head(sRNA_data)
#'
#'
#' @export
#' @importFrom data.table "data.table"
#' @importFrom data.table "setnames"
#' @importFrom utils "read.table"
#' @importFrom data.table "fread"
#' @importFrom dplyr "mutate"
#' @importFrom dplyr "across"
#' @importFrom dplyr "contains"
#' @importFrom tidyr "replace_na"
#' @importFrom data.table ":="
#' @importFrom dplyr "%>%"
#' @importFrom dplyr "filter"
#' @importFrom dplyr "if_any"
#' @importFrom dplyr "where"
#' @importFrom stats "setNames"
#' @importFrom utils "flush.console"
RNAimport <- function(input = c("sRNA"), directory, samples,
                       tidy = TRUE, FPKM = FALSE) {
  if (base::missing(input) || !input %in% c("sRNA")) {
    stop("Please state the data-type to the `input` paramter. Currently, only 
          `sRNA` data is accepted.")
  }
  if (base::missing(directory)) {
    stop("Please specify an accessable directory where files are stored")
  }
  if (base::missing(samples)) {
    stop("Please specify a vector storing sample names matching files")
  }
  if(input=="sRNA"){
    # LOad sample data as list of data frames, with index as file name.
    dt_list <- list()
    total_files <- length(samples)
    file_n <- 0
    for (file in samples) {
      file_n <- file_n + 1
      options(datatable.showProgress = FALSE)
      dt_list[[file]] <- data.table::fread(file.path(directory, file,
                                                  "Results.txt"),header = TRUE)
      progress_counter <- file
      progress_message <- paste0("Processing sample: ", progress_counter,
                                 "\n",
                                 "File ", file_n, " of ", total_files)
      message(sprintf("\r%s", progress_message))
      utils::flush.console()
    }
    message("Completed importation of data from directory.")
    # remove any hashtags from header - added by shortstack
    dt_list <- lapply(dt_list, function(x) setNames(x, gsub("#", "", names(x))))
    # Check each data frame in the list for the required columns
    message("Checking data content...")
    required_cols <- c("Locus", "DicerCall", "Reads", "MajorRNA")
    for (df in dt_list) {
      if (!all(required_cols %in% colnames(df))) {
        stop("Sample data frame does not contain all required columns: ",
             paste(setdiff(required_cols, colnames(df)), ".", collapse = ", ",
                   "Make sure there is not a hashtag or similar in the header
                   line of the input file(s)"))
      }
    }
    message("Data content is correct.")
    # merge first columns to create list of loci across all samples
    loci <- lapply(dt_list, "[", , "Locus")
    loci_all <- unique(Reduce(merge,loci))
    # Define a function to update the loci with the matching values from a
    # single input dataframe
    update_locus_df <- function(dt, i) {
      # Join loci and the current input df on chromosome and coordinate range
      join_cols <- c("Locus")
      dt_match <- loci_all[dt, on = join_cols, nomatch = 0]
      # Aggregate the matching rows by chromosome, start coordinate, & end coor,
      # and compute the sum of DicerCall, Reads, and RPM values for each group
      dt_agg <- dt_match[, .(Width=sum(Length),
                             DicerCall = as.character(DicerCall),
                             Count=sum(Reads),
                             MajorRNA = as.character(MajorRNA)),
                         by = join_cols]
      # Rename the aggregated columns
      total_counts <- sum(dt_agg$Count)
      RPM_cal <- (dt_agg$Count / total_counts) * 1e6
      dt_agg$RPM <- RPM_cal
      if(FPKM){
        dt_agg$FPKM <- (dt_agg$RPM / (dt_agg$Width / 1000)) / sum(dt_agg$RPM) * 1e6
        col_names <- paste0(c("DicerCall_", "Count_", "MajorRNA_", "RPM_", "FPKM_"),  i)
        data.table::setnames(dt_agg, c("Locus","Width", col_names))
      }else {
        col_names <- paste0(c("DicerCall_", "Count_", "MajorRNA_", "RPM_"),  i)
        data.table::setnames(dt_agg, c("Locus","Width", col_names))
      }
      
      # Merge the aggregated values back into df1
      loci_all[dt_agg, on = join_cols, (col_names) := mget(col_names)]

    }
    # Update loci with the matching values from each input dataframe
    for (i in seq_len(length(dt_list))) {
      update_locus_df(dt_list[[i]], names(dt_list)[i])
    }
    # Fill in missing values with 0 or N
    ## Dicer call needs to character/factor
    loci_all <- loci_all %>%
      dplyr::mutate(dplyr::across(dplyr::contains('Count_'),
                                  ~tidyr::replace_na(.,0))) %>%
      dplyr::mutate(dplyr::across(dplyr::contains('RPM_'),
                                  ~tidyr::replace_na(.,0))) %>%
      dplyr::mutate(dplyr::across(dplyr::contains('DicerCall_'),
                                  ~tidyr::replace_na(.,"N")))%>%
      dplyr::mutate(dplyr::across(dplyr::contains('MajorRNA_'),
                                  ~tidyr::replace_na(.,"N"))) %>%
      dplyr::mutate_all(~ ifelse(. == "*", "N", .)) # remove any astriks to "N"
    # Convert loci_all back to a data.frame and return it
    res_data <- as.data.frame(loci_all)
    # Split the Locus column into three new columns
    locus_cols <- data.frame(
      chr = sapply(strsplit(res_data$Locus, split = ":"), "[[", 1),
      start = sapply(strsplit(sapply(strsplit(res_data$Locus, split = ":"),
                                     "[[", 2), split = "-"), "[[", 1),
      end = sapply(strsplit(sapply(strsplit(res_data$Locus, split = ":"),
                                   "[[", 2), split = "-"), "[[", 2)
    )
    df_final <- cbind(res_data[,1], locus_cols, res_data[, 2:ncol(res_data)])
    names(df_final)[1] <- "Locus"
    # order by chr
    df_final <- df_final[order(df_final$chr),]
    # insert cluster name
    cluster_names <-  paste0("cluster_", seq_len(nrow(df_final)) )
    df_final <- as.data.frame(append(df_final, list(Cluster = cluster_names),
                                     after = 4))
# Remove rows with no counts 
count_columns <- grep("^Count", names(df_final))
# Identify rows where all values in Count columns are zero
rows_to_remove <- apply(df_final[count_columns], 1, function(row) all(row == 0))
# Remove rows with all zero values in Count columns
df_final <- df_final[!rows_to_remove, ]   
    # return values
    return(df_final)
  } 
}










