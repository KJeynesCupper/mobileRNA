#' Identify potential mobile sRNA molecules
#'
#' @description A function to identify potential mobile small RNA molecules
#' traveling from one genotype to another in a hetero-grafted system.
#'
#' @details
#' The function undertakes two different roles. First, it selects the sRNA
#' cluster which are mapped to a particular genome. It does so by either keeping
#' or removing sRNA mapped to chromosomes. Hence, this function will only work
#' if the two genomes are distinguishable by their chromosome names.
#'
#' The second step, after selecting clusters which are mapped to the genome of
#' interest, removes sRNA clusters which were incorrectly mapped. These
#' are clusters which have counts or RPM values in the control samples
#' (ie. same genome as the destination tissue in the hetero-graft condition).
#' These samples should not have counts if the sRNA originates from a different
#' genotype to the control.
#'
#' The function also allows for statistical analysis based on the results
#' collect from differential analysis of the total dataset using the function
#' [mobileRNA::RNAdifferentialAnalysis()]. This features enables the filtering 
#' of sRNA clusters which meet a specific p-value or adjusted p-values.
#'
#'
#' A greater confidence in the mobile sRNA candidates can be achieved by setting 
#' a threshold that considers the number of replicates which contributed to 
#' defining the consensus dicer-call (ie. consensus sRNA classification). This
#' parameter filters based on the `DicerCount` column introduced by the 
#' [mobileRNA::RNAdicercall()] function.  
#' 
#' 
#' @param data data.frame; generated by [mobileRNA::RNAimport()]
#'
#' @param controls character; vector containing strings represening names of 
#' control samples in data.frame.
#'
#' @param genome.ID character; common string related to the chromosomes in a 
#' particular genome. A distinguishing feature of the genome of interest or 
#' non-interest in the chromosome name (`chr` column).
#'
#' @param task character; either "remove" or "keep". An option to keep or remove 
#' the chromosomes containing the identifying string. To keep the chromosomes 
#' with the ID, set task=keep. To remove, set `task="remove"`. As default, task 
#' is set to `keep`.
#'
#'
#' @param statistical logical; If TRUE, will undertake statistical filtering 
#' based on the a p-value or adjusted p-value threshold stated by `padj` & 
#' `p.value`.Default setting `statistical=FALSE`. Requires presence of columns 
#' containing statistical data. In order to filter by the adjusted p-value, a 
#' column named `padjusted` must be present. Similarly, to filter by the 
#' p-value, a column named `pvalue` must be present. See 
#' [mobileRNA::RNAdifferentialAnalysis()] to calculate statistical values.
#'
#'
#' @param padj numeric; user defined numeric value to represent the adjusted 
#' p-value threshold to define statistic significance. Defaults setting 
#' `padj=0.05`. Returns sRNA clusters with an adjusted p-values equal or lower 
#' than the threshold value.
#'
#' @param p.value numeric; user defined numeric value to represent the p-value
#' threshold to define statistic significance. There is no default value, set
#' this instead of using an adjusted p-value to filter sRNA cluster. 
#'
#'@param threshold numeric; set a threshold level for the the number of 
#'replicates that defined the dicer-derived sRNA consensus. 
#'
#' @return A data-frame containing candidate mobile sRNAs, which could be 
#' further filtered based on statistical significance and the ability to 
#' by-pass the threshold which determines the number of replicates that 
#' defined the dicer-derived sRNA consensus.
#'
#' @examples
#'
#'
#'data("sRNA_data_consensus")
#'
#'
#' # vector of control names
#' controls <- c("selfgraft_1", "selfgraft_2" , "selfgraft_3")
#'
#' # Locate potentially mobile sRNA clusters associated to tomato, no
#' # statistical analysis
#' mobile_df1 <- RNAmobile(data = sRNA_data_consensus,
#'                     controls = controls,
#'                     genome.ID = "SL40",
#'                     task = "keep",
#'                     statistical = FALSE)
#'
#'
#'
#'  # Locate potentially mobile sRNA clusters associated to tomato, include
#'  # statistical analysis
#'
#' ## undertake statistical analysis with either edgeR or DESeq2, here we use
#' # # DESeq2
#' groups <- c("Heterograft", "Heterograft", "Heterograft",
#'           "Selfgraft", "Selfgraft", "Selfgraft")
#'
#' analysis_df <- RNAdifferentialAnalysis(data = sRNA_data_consensus,
#'                              group = groups,
#'                              method = "DESeq2" )
#'
#' ## locate mobile sRNA using p-adjusted value
#' mobile_df2 <- RNAmobile(data = analysis_df,
#'                     controls = controls,
#'                     genome.ID = "SL40",
#'                     task = "keep",
#'                     statistical = TRUE)
#'
#' ## or, locate mobile sRNA using p-value value
#' mobile_df3 <- RNAmobile(data = analysis_df,
#'                     controls = controls,
#'                     genome.ID = "SL40",
#'                     task = "keep",
#'                     statistical = TRUE,
#'                     p.value = 0.05)
#'
#'
#'
#'# Locate local sRNA clusters associated to eggplant, include statistical
#'# analysis
#' mobile_df4 <- RNAmobile(data = sRNA_data_consensus,
#'                     controls = controls,
#'                     genome.ID = "SL40",
#'                     task = "remove",
#'                     statistical = FALSE)
#'
#'
#' @export
#' @importFrom dplyr "%>%"
#' @importFrom dplyr "filter"
#' @importFrom dplyr "select"
#' @importFrom tidyselect "starts_with"
#' @importFrom dplyr "case_when"
RNAmobile <- function(data,controls, genome.ID, task = NULL ,
                      statistical = FALSE, padj = 0.05, threshold = NULL, 
                      p.value = NULL){
  if (!base::inherits(data, c("matrix", "data.frame", "DataFrame"))) {
    stop("data must be an object of class matrix, data.frame, DataFrame")
  }
  if (base::missing(controls) || !base::inherits(controls, "character")) {
    stop("Please specify a character vector storing names of control
               replicates")
  }
  if (base::missing(genome.ID) || genome.ID %in% "") {
    stop("Please specify a single character string which is present in
               the all the chromosomes within the genome you wish to keep
               or remove")
  }
  x <- data %>%
    dplyr::filter(dplyr::case_when(
      is.null(task) & base::grepl(genome.ID, chr) ~ TRUE,
      task == "remove" & !base::grepl(genome.ID, chr) ~ TRUE,
      task == "keep" & base::grepl(genome.ID, chr) ~ TRUE,
      TRUE ~ FALSE
    ))
  res <- .remove_mapping_errors(data = x, controls = controls)
  # Remove rows with no counts 
  count_columns <- grep("^Count", names(res))
  # Identify rows where all values in Count columns are zero
  rows_to_remove <- apply(res[count_columns], 1, function(row) all(row == 0))
  # Remove rows with all zero values in Count columns
  res <- res[!rows_to_remove, ]
  if (statistical) {
    if (is.null(p.value)) {
      res <- res %>% filter(padjusted <= padj)
    } else
      res <- res %>% filter(pvalue <= p.value)
  } 
  if(!is.null(threshold)){
    res <- res %>% filter(!DicerCounts < threshold)
  }
  return(res)
}

