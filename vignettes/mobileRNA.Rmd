---
title: "mobileRNA: Explore sRNAs or mRNAs mobilome & population-scale changes"
author: "Katie Jeynes-Cupper, Marco Catoni"
date: "`r format(Sys.Date(), '%m/%d/%Y')`"
abstract: >
  In my different instances, a growing number of researchers are turning to 
  genomic analysis to identify putative difference between RNA populations and 
  specifically to identify molecules which originate from a foriegn genome or 
  genotype. For which, plant grafting is a perfect example which has been 
  used for such studies as the technique can join differnt plant species or 
  accession together generating a plant with combined tissues two distinct 
  genotypes. For the identification of mobile or forign RNAs, such as messenger 
  RNA or small RNA, genomic pipelines typically manipulate RNA-seq workflows 
  with consequential mapping to each genome in the system. This comes with 
  benefits and disadvantages. Here, we addess the main disadvantages; the high
  levels of data noise and false positives. The package mobileRNA provides
  methods to pre-processs, analyse and visualse the sRNA and mRNA populations. 
  This vignette explains the use of the package and demonstrates quick and 
  more advanced workflows. 
output:
  rmarkdown::html_document:
    highlight: pygments
    toc: true
    fig_width: 5
bibliography: library.bib
vignette: >
 %\VignetteIndexEntry{mobileRNA}
 %\VignetteEngine{knitr::rmarkdown}
 %\VignetteEncoding{UTF-8}
 %\VignetteDepends{bioseq}
 %\VignetteDepends{dplyr}
 %\usepackage[utf8]{inputenc}
---


```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  fig.align='center',
  external=TRUE,
  echo=TRUE,
  warning=FALSE,
  comment = "#>"
)
library(dplyr)
library(bioseq)
```

# Introduction

In plants, systemic signalling is an elaborated molecular system which 
coordinates plant development, integrating and transmitting the information 
perceived from environment to distant organs. An important role in long-distance 
signalling is played by small RNA molecules (sRNAs). The nucleotide length 
of a sRNA helps researches identify the class of sRNA and predict its 
functionality. Micro-RNAs (miRNAs) have a length between 21- and 23-nt, and are
involved in directing translational repression and/or the cleavage of messenger 
RNAs (mRNAs). Whereas, small interfering RNAs (siRNAs) have a length of 24-nt, 
and are involved in the addition of DNA methylation through the RNA-directed
DNA methylation pathway (RdDM) and account for the majority of sRNAs in plants. 
These endogenous sRNAs can be produced in a tissue and then transported 
systemically across the vascular system into recipient organs, where they can 
induce a molecular response and coordinate physiological changes. Similarly, 
studies have shown that messenger RNAs (mRNAs) can move across distances, and it 
is thought they may translate into proteins which act as transcription factors 
in the recipient tissues. Plant grafting can be utilised to create chimeric 
plant systems composed of two genotypes. For example, grafting can join two 
different species, such as tomato and eggplant, or different plant varieties or
accessions. Grafting of horticultural crops can lead to favorable traits, such 
as improved plant vigour or architecture, and resistance to stress. sRNAs have
been known to move across a graft junction, hence, understanding the complex 
regulatory networks controlled by sRNAs traveling from different genomes could 
assist the development of novel methods for transferring traits into crops, as 
alternatives to traditional breeding or transgenic approaches.

Several genomic studies have used grafting to explore and characterise mobile 
sRNAs in chimeric systems, however, it is clear that there is not a standardised 
approach. To identify sRNA population which are mobile or native, analysts 
currently adopt a general RNA sequencing pipeline. However, we believe these 
approaches may have several limitations. Here we introduce the R package, 
`mobileRNA`, a recommended pipeline and analysis workflow for the identification 
of mobile sRNAs/mRNA. In addition, the flexibility supports standard sRNAseq 
analysis between treatment and control conditions. For example, to identify sRNA 
population changes due to the application of a treatment such as cold/heat 
stress or exposure to a pest. `mobileRNA` ultimately assists pre-processing and
analysis including the characterization of different populations, visualization 
of the results, and supports output for functional analysis. 

As stated this was developed for applications for plant grafting experimental 
analysis, however, we believe it could have further application including 
the analysis of dual-host system. 

<br>

# Approach

Mobile RNA molecules can travel systemically in plants systems. In grafted 
plants, when different genotypes are used as rootstock and scions, the sequence 
variation between the two genomes involved can be used to discriminate the 
origin of a sequenced RNA molecule. Therefore, if an RNA molecule sequenced 
from one of the grafted partners (scion or rootstock) has found matching the 
genome of the other grafting partner, this could empirically demonstrate it's 
movement across the graft junction.

Most available genomics approaches to implement this analysis are based on RNA 
sequencing, following by alignment on a genotype of reference and post alignment 
screening of genetic variants to identify molecules which have better match for 
the genotype of the grafted partner. These methods have many limitations, which 
might include:

*	High dependency on arbitrary thresholds to determined mapped and unmapped RNAseq reads.
*	Use of additional statistical test to discriminate genetic variations from sequencing noise in post alignment analysis.
*	High false positive rates. 

Here, to circumvents such problems we propose a method inspired by the RNAseq 
analysis of plant hybrids, including an alignment step performed simultaneously 
on both genomes involved. The rational of this approach considers that alignment 
tools already implement an algorithm ideal for identification of the best 
matches (accordingly to set parameters) in a given genome reference, but they do 
not account for potential matches to DNA sequences which are not provided as 
reference. Therefore, the two genomes from all partners involved in the 
chimeric system are merged in a single FASTA file and used as reference for 
the unique alignment. In a bid to supply the algorithm with as much 
information as possible to make the best possible predictions and placement of
sequencing reads to each genome. Then, `mobileRNA` will filter RNAs which 
uniquely map on the genome of the other grafting partner involved, which 
would represent the putative mobile RNA molecules.

The summarised workflow is shown below, where it contains a core RNA analysis
and a mobile sRNA/mRNA analysis. The core analysis represents the standard 
workflow for the identification of native population difference, for example the 
sRNA population difference between treatment and condition samples, or similarly 
in a chimeric system, such as plant grafting, we might want to explore the 
native sRNA population from the sample tissue origin (ie. leaf) which have been 
lost or gained or changes in sRNA abundance. While the mobile analysis, 
represents the workflow for the identification of putative mobile sRNAs or 
mobile mRNA in a chimeric system.

As input, the pipeline requires clean small RNA sequencing reads in FASTQ 
format, along with the genome assemblies which represent the genotypes in the
system. 

<br><br>
```{r, fig.align="centre", echo=FALSE,out.width="750", out.height="750",fig.cap="The analysis pipeline for mobileRNA" }

knitr::include_graphics("../man/figures/mobileRNA_graphic_1.png")
```
<br><br><br>

The above figure illustrates workflow, including the merging of the two 
reference which represent the two genotypes in the chimeric system, the
designed alignment steps and the analysis steps. 

The analysis workflow can be completed in a simple process to identify 
potentially mobile RNAs and/or to explore the population dynamics. The analysis
can be advanced with the following extra features: 

* Principal component analysis
* Heatmaps 
* Distribution plots
* Statistical analysis with `edgeR` or `DESeq2` methods
* Steps to assist functional analysis. 

The diagram below illustrates the complete workflow using `mobileRNA`, including
essential, optional and plotting functions:

<br><br>
```{r, fig.align="centre", echo=FALSE,out.width="750", out.height="750",fig.cap="The analysis pipeline for mobileRNA" }

knitr::include_graphics("../man/figures/mobileRNA_graphic_2.png")
```
<br>

The analysis approach includes several underlying features to be aware of which 
can alter the final output. When working with a chimeric system, the core steps 
offer the ability to remove mapping errors by comparing control samples to the 
treatment samples. If the genotypes in the chimeric system are fairly distantly 
related, it is unexpected that unique reads aligned to the foreign/mobile
genotype will be found in the control samples. With that in mind, we can assume
RNAs with reads mapped to the foreign/mobile genotype from the control 
samples could be artifacts or mapping errors. Hence, these RNAs  are 
removed from the analysis when the parameters are utilsed. Note that, if the 
chimeric system is expected to share some or a high level of similarity it might 
be insightful to the analysis to not remove these sRNA clusters. 

After importing the data into R using `RNAimport()`, the second core 
step is the consensus dicercall classification (see function 
`RNAdicercall()`). For a given sRNA cluster, within each sample a 
sRNA classification is predicted. This information is used to define the 
classification of the cluster based on the consensus across replicates, which is
added as an additional column to the dataframe. As well a further column which 
states the number of replicates which contributed to the consensus class. There 
is a range of parameters to control how these are drawn, making it either 
stringent or loose, which may alter the downstream analysis. These are mainly
related to handling ties. 

The third core step involves the use of differential analysis. It should be 
emphasized that this is an optional step for the identification of mobile RNAs, 
while, for the exploration of population dynamics it is a mandatory step. 
Here we include a single function which can be instructed to undertake 
differential analysis using either the `edgeR` or `DESeq2` method (see function 
`RNAdifferentialAnalysis()`).  The function outputs additional columns 
to your working dataset, including the raw count mean, log2FoldChange, p-value 
and adjusted p-value. 

Here we describe the final steps for each workflow. For mobile RNA analysis, we 
introduce the `RNAmobile()` function. It contains parameter which can 
either result in stringent or looser outcomes by utilises the number of 
replicates which contributed to the consensus dicercall classification (sRNA) or
which contribute to the raw read count (mRNA) as a threshold value. 
For instance, it would be more stringent to select sRNA 
clusters which were unambiguously classified across condition replicates. While,
for the core RNA analysis, the final step to identify population changes is to 
locate RNAs which are unique to the treatment replicate and a set of RNAs
which are unique to the control replicates. Ultimately, this will identify 
RNAs which were gained or lost due to the treatment in comparison to 
the controls. Moreover, the RNA abundance explored to identify statistically 
significant changes in abundance between RNAs in the treatment and 
control samples. 

At the end of the basic analysis, the user will have generated a dataframe
where rows represent either sRNA clusters or mRNAs and the columns include 
information on the sRNA clusters or mRNAs, individual sample replicates, 
and more: 

** For sRNA analysis ** 
#### Information on the sRNA cluster:

- `Locus`: Genomic location
- `chr`: Name of the chromosome or scaffold
- `start` : Start position of the cluster
- `end` : End position of the cluster
- `Cluster`: Cluster Name 
- `DicerConsensus` : Consensus dicercall (Calculated by `RNAdicercall()`)
- `DicerCounts` : Number of replicates which contributed to the consensus dicercall sRNA class (Calculated by `RNAdicercall()`)
- `CountMean` :  Count mean (Calculated by `RNAdifferentialAnalysis()`)
- `log2FoldChange` : Log fold change (Calculated by `RNAdifferentialAnalysis()`)
- `pvalue` : p-value (Calculated by `RNAdifferentialAnalysis()`)
- `padjusted` : Adjusted p-value (Calculated by `RNAdifferentialAnalysis()`)
- `logCPM` : Log counts per million (CPM/RPM) (Calculated by `RNAdifferentialAnalysis()`)

#### Information on each sample replicate:

- `DicerCall_` : The size of most abundant sRNA 
- `Count_` : Number of aligned sRNA reads. As default, these are uniquely aligned (*e.g.* not multi-mapping).
- `RPM_` : Reads per Million mapped reads 
- `FPKM_` : Fragments Per Kilobase of transcript per Million mapped reads 
- `MajorRNA_` : RNA sequence of most abundant sRNA in the cluster

** For mRNA analysis ** 
#### Information on the mRNA:
- `Feature`: mRNA name
- `SampleCounts` : Consensus dicercall (Calculated by `RNAdicercall()`)
- `CountMean` :  Count mean (Calculated by `RNAdifferentialAnalysis()`)
- `log2FoldChange` : Log fold change (Calculated by `RNAdifferentialAnalysis()`)
- `pvalue` : p-value (Calculated by `RNAdifferentialAnalysis()`)
- `padjusted` : Adjusted p-value (Calculated by `RNAdifferentialAnalysis()`)
- `logCPM` : Log counts per million (CPM/RPM) (Calculated by `RNAdifferentialAnalysis()`)

#### Information on each sample replicate:

- `Count_` : Number of aligned mRNA reads. As default, these are uniquely aligned (*e.g.* not multi-mapping).
- `FPKM_` : Fragments Per Kilobase of transcript per Million mapped reads 

If more advanced steps were taken a PCA plot, distance matrix, sRNA class 
distribution plot and heatmap plots could have been generated. Plus, utilsation 
of the functions to assist functional analysis can support the determination 
of the biological implications.  From the core analysis, the user can 
explore difference in RNA production within the samples and compare RNA 
abundance. While both core and mobile analysis, the user can extract the 
consensus RNA sequence for each sRNA cluster for target prediction analysis, as 
well as identifying genomic features associates with each sRNA clusters, such 
as genes. This can be utilised, for example, to explore the RNA expression of 
sRNA-producing genes in parallel analysis.


# Installation

The latest version of `mobileRNA` can be installed via Bioconductor:

```{r,  eval=FALSE, message=FALSE}
if (!require("BiocManager", quietly = TRUE))
    install.packages("BiocManager")

BiocManager::install("mobileRNA")
```

It is also available on GitHub:
```{r,  eval=FALSE, message=FALSE}
if (!require("devtools")) install.packages("devtools")
devtools::install_github("KJeynesCupper/mobileRNA", ref = "main")

```


```{r, message=FALSE}

library("mobileRNA")

```


## Installing OS dependancies 

`mobileRNA` works on systems with `R`, and depending on the type of sequencing
data different OS dependencies installed via Conda are required for the 
alignment steps. 

For sRNA data, `ShortStack` (>= 4.0) (Axtell 2013) is requires. Please consider 
that `ShortStack` is not available for Windows, hence, Windows users will either 
need to opt to use a virtual machine or 
[Windows Subsystem for Linux](https://docs.microsoft.com/en-us/windows/wsl/install-win10)
In either case, both `R` and `ShortStack` will need to be installed and used on 
the Linux side.Please head to `ShortStack` to see the recommended installation 
instructions at 
\url{https://github.com/MikeAxtell/ShortStack#install-using-conda-recommended}
for installation with Conda (Anaconda Inc. 2020). This will ensure all 
dependencies are available within the same environment. 

For mRNA data, `HISAT2` (Kim et al., 2015), `HTSeq` (Anders 2014), `SAMtools` 
(Danecek et al., 2021) are required within the same 
Conda environment (Anaconda Inc. 2020). Please refer to 
\url{https://anaconda.org/bioconda/hisat2},
\url{https://anaconda.org/bioconda/htseq} and 
\url{https://anaconda.org/bioconda/samtools} for more information. 

## Example Data

The package includes a simulated data set to replicate the grafting
between eggplant-tomato (*Solanium melongena*-*Solanium lycopersicum*) where 
eggplant represents the scion and tomato represents the rootstock. The FASTQ 
files represent sRNAseq data extracted from the eggplant leaf tissue. Here we 
will locate sRNA produced by tomato roots which have traveled into the eggplant 
leaves. There are three heterograft replicate, where each is an individual 
tomato replicate spiked with the same random set of tomato sRNA clusters. 
These are known as:

* `heterograft_1`
* `heterograft_2`
* `heterograft_3`  

There are three self-graft replicates, where each is an individual tomato 
replicate without the spiked tomato sRNA clusters. These are:

* `selfgraft_1`
* `selfgraft_2` 
* `selfgraft_3`

The replicates mirror each other where, for instance, `heterograft_1` 
and `selfgraft_1` are the same replicate, either with or without the spiked 
clusters. 

For sRNAseq & mRNAseq alignment, we provide demo fastq files; these have a 
reduced number of reads and do not cluster as expected which are stored 
within `inst/extdata`. 

Hence, we also provide more comprehensive data sets, for small RNA it is called
`sRNA_data` and for messenger RNA it is called `mRNA_data`. Each stores an 
example dataframe produced by the importation step with  `RNAimport()`. This can 
be loaded in the R environment by using the following command:


```{r Load, message=FALSE}

data("sRNA_data")

data("mRNA_data")

```
The sRNA simulated data was generated from the data published by Li 2022 and 
Qing 2022 and the mRNA simulated data was generated from the data published
by Villanueva et al., 2023 and Tomato Genome Consortium 2012. 

Tomato and Eggplant reduced genome assemblies and annotations have been provided
based on those generated by Hosmani et al., 2019 and Barchi et al., 2021.
## Data organisation
It is recommended to rename your files before beginning to names you wish for 
them to be represented as within the analysis; named in the dataframe and shown 
as labels in plots. 

For example, instead of names such as:

- 1: `sample_1.fq`
- 2: `sample_2.fq`
- 3: `sample_3.fq`
- 4: `sample_4.fq`
- 5: `sample_5.fq`
- 6: `sample_6.fq`

For the example data set included in the package, here we have renamed the
files based on the condition (treatment or control).For the heterografts, where 
the is a eggplant scion and an tomato rootstock:

- 1: `heterograft_1.fq`
- 2: `heterograft_2.fq`
- 3: `heterograft_3.fq`

and for the eggplant self-grafts:

- 4: `selfgraft_1.fq`
- 5: `selfgraft_2.fq`
- 6: `selfgraft_3.fq`
<br>

# Quick start
This quick-start includes instructions for sRNA and mRNA analysis.
## 1. Merging Genome Assemblies 
Merge the FASTA genome assemblies of tomato and eggplant into a single
reference file stored in your desired directory.Eggplant represent the scion
(native) genome A, and tomato represents the rootstock (foreign/mobile) genome
B. 


```{r}
fasta_1 <- system.file("extdata","reduced_chr12_Eggplant.fa", 
                       package="mobileRNA")

fasta_2 <-system.file("extdata","reduced_chr2_Tomato.fa",
                      package="mobileRNA")
# define temporary output directory - replace with your directory
output_assembly_file <- file.path(tempfile("merged_assembly", 
                                           fileext = ".fa"))

# merge
merged_reference <- RNAmergeGenomes(genomeA = fasta_1,
                                    genomeB = fasta_2,
                                    output_file = output_assembly_file)
```

<br>
## 2. Merging Genome Annotations 
Now, repeat for the genome annotations (GFF) - this is required for downstream 
analysis or for mRNA mapping

*It is important that the same alterations are made to each genome in the merged
files -  otherwise the annotation file will not align with the chromosome names 
in the assembly file.*
<br>

```{r}

anno1 <- system.file("extdata","reduced_chr12_Eggplant.gff",
                     package="mobileRNA")

anno2 <- system.file("extdata","reduced_chr2_Tomato.gff", 
                     package="mobileRNA")

# define temporary output directory 
output_annotation_file <- file.path(tempfile("merged_annotation", 
                                             fileext = ".gff3"))

# merge annotation files into a single file
merged_annotation <- RNAmergeAnnotations(annotationA = anno1,
                                         annotationB = anno2,
                                         output_file = output_annotation_file)

```

## sRNA analysis
### 1. Alignment (demo only)

Here we will align our samples containing small RNA sequencing reads to the 
merged genome assembly created earlier. The `mapRNA()` function requires 
three core inputs:
  
* 1 - The directory containing the FASTQ files for all the samples in the analysis 
* 2 - The directory to store the output 
* 3 - The directory to genome assembly file (.fa or .fasta)

The function invokes a system command to `ShortStack`; an application which 
employs Bowtie mapping and performs comprehensive de novo annotation and 
quantification of sRNA genes. The function first undertakes de novo sRNA
cluster detection (stored in `1_de_novo_detection`) and then quantification of 
sRNA genes (stored in`2_alignment_results`). 

** PLEASE NOTE: For the alignment & import demo, we are using fastq files which 
have a reduced size for the package. This data will not be used for the 
continued analysis step, instead you will load the full dataset ** 

```{r, eval=FALSE}
samples <- system.file("extdata/sRNAseq",package="mobileRNA")

output_location <- tempdir()

mapRNA(input = "sRNA",
       input_files_dir = samples, 
       output_dir = output_location, 
       genomefile = output_assembly_file,
       condaenv = "/Users/user-name/miniconda3/envs/ShortStack4",
       mmap = "n")

```
Since we are using chimeric samples, we use `mmap = n` to exclude multi-mapped
reads. 

If there are issues utilising this function, the manual steps are illustrated in 
the appendix. 
<br>

### 2. Import Pre-Processed Data into R (demo only)
Import the results from the alignment step into R using the
`RNAimport()` function. This requires the directory storing the sample
output folders and the same of the samples to import from the directory.

```{r, eval=FALSE}
# Directory containing results
results_dir <-  file.path(output_location,"2_alignment_results")

# Sample names and total number of reads, in the same order. 
sample_names <- c("selfgraft_demo_1", "selfgraft_demo_2", 
                  "selfgraft_demo_3", "heterograft_demo_1",
                  "heterograft_demo_2", "heterograft_demo_3")


sRNA_data_demo <- RNAimport(input = "sRNA", 
                       directory = results_dir,
                       samples = sample_names)
                           
```
<br>

This will generate a dataframe where rows represent sRNA clusters and 
contains the following columns: 
  
- `Locus`: Genomic location
- `chr`: Name of the chromosome or scaffold
- `start` : Start position of the cluster
- `end` : End position of the cluster
- `Cluster`: Cluster Name

For each sample, the following columns will be present. Where the sample name 
following after the underscore: 
  
- `DicerCall_` : The size of most abundant small RNA size
- `Count_` : Number of uniquely aligned reads that overlap the locus.
- `RPM_` : Reads per Million
-  `FPKM` : Fragments Per Kilobase of transcript per Million
- `MajorRNA_` : RNA sequence of the most abundant sRNA in the cluster



### 3. Import example data 
Load full analysis dataset for more comprehensive analysis.

```{r}
data("sRNA_data")

```


### 4. Calculate the Consensus Dicercall

For a given sRNA cluster, each replicate has determined the dicercall,
also known as the sRNA class, based on the length in nucleotides of the
most abundant sRNA. This can be drawn from all samples or named samples.
The output can be used as threshold values for downstream analysis, and
to remove data noise depending on data quality.

```{r}

sRNA_data_dicercall <- RNAdicercall(data = sRNA_data, tidy = TRUE )

```

<br>

### 5. Differential Analysis of sRNA Population

Undertake differential analysis of sRNA within the experimental design
to explore changes in abundance. The function allows for two methods;
`edgeR` or `DESeq`.

```{r}
## sample conditions in order within dataframe
groups <- c("Selfgraft", "Selfgraft", "Selfgraft", 
            "Heterograft", "Heterograft", "Heterograft")


## Differential analysis of whole dataset: DESeq22 method 
sRNA_DESeq2 <- RNAdifferentialAnalysis(data = sRNA_data,
                                       group = groups,
                                       method = "DESeq2")
```


```{r, eval=FALSE}
# save output as txt file 
write.table(sRNA_DESeq2, "./sRNA_DA_output.txt")

```

Summarise results:

```{r}

RNAsummary(sRNA_DESeq2)

```

How about summarizing the sRNA population which are statistically
significant:

```{r}

RNAsummary(sRNA_DESeq2, alpha=0.05)

```

### 6. Identify Potential Mobile sRNA

Select the putative mobile sRNA clusters using `RNAmobile()`. This
requires supplying the function with a unique identifier of the
rootstock genome. The merging step placed the prefix "B" to the tomato
chromosomes.

```{r}
# define control samples
controls <- c("selfgraft_1", "selfgraft_2", "selfgraft_3")

mobile_sRNA <- RNAmobile(input = "sRNA",
                         data = sRNA_DESeq2, 
                         controls = controls,
                         genome.ID = "B",
                         task = "keep")
```


```{r, eval=FALSE}
# save output as txt file 
write.table(mobile_sRNA, "./sRNA_mobile_output.txt")

```

<br>

### Output

A data frame where rows represent potential mobile sRNA clusters. The
columns include information on the cluster, individual sample
replicates, and more.

##### Information on the cluster:

-   `Locus`: Name of the chromosome or scaffold, start position & end position
-   `chr`: Name of the chromosome or scaffold
-   `start` : Start position of the cluster
-   `end` : End position of the cluster

##### Information on each sample replicate:

-   `Cluster`: Cluster Name
-   `Dicercall` : The size of most abundant small RNA size
-   `Count` : Number of reads, default is uniquely aligned (*e.g.* not multi-mapping).
-   `MajorRNA` : RNA sequence of the most abundant sRNA in cluster within the sample
-   `RPM` : Reads per Million
-   `FPKM` : Fragments Per Kilobase of transcript per Million

##### Other information

-   `DicerConsensus` : Consensus sRNA class
-   `DicerCounts` : Number of replicates which contributed to the consensus dicercall sRNA class
-   `CountMean` : Count mean (Calculated by `RNAdifferentialAnalysis()`)
-   `log2FoldChange` : Log2FoldChange--The effect size estimate
-   `pvalue` : P value, the probability under the assumption of no
    effect or no difference, of obtaining a result equal to or more
    extreme than what was actually observed
-   `padjusted` : A p-value adjustment
-   `logCPM` : log counts per million, measure of expression level <br>
-   `comparision.order` : Comparison conditions

## mRNA analysis

### 1. Alignment 

Align mRNA sequencing reads to the merged genome using our unique
alignment pipeline wrapped by the `mapRNA()` function.

note:not runnable
```{r, eval=FALSE}

sampleData <- data.frame(sample = c("selfgraft_1", "selfgraft_2", 
                                    "heterograft_1", "heterograft_2"),
                        mate1 = c("selfgraft_mRNAdemo_1.fq", "selfgraft_mRNAdemo_2.fq", 
                                  "heterograft_mRNAdemo_1.fq", "heterograft_mRNAdemo_2.fq"))

samples <- system.file("extdata/mRNAseq", package="mobileRNA")
output_location <- tempdir()
 
mapRNA(input = "mRNA",
       input_files_dir = samples, 
       output_dir = output_location, 
       genomefile = output_assembly_file,
       annotationfile = output_annotation_file,
       sampleData = sampleData, 
       condaenv = "/Users/user-name/miniconda3")

```

<br>

### 2. Import Pre-Processed Data into R 

Import the results from the alignment step into R using the
`RNAimport()` function. This requires the directory storing the sample
output folders and the same of the samples to import from the directory.

note:not runnable
```{r, eval=FALSE}
# Directory containing results
results_dir <-  file.path(output_location,"1_mRNA_preprocessing")

# Sample names and total number of reads, in the same order. 
sample_names <- c("selfgraft_1", "selfgraft_2", "selfgraft_3",
                  "heterograft_1", "heterograft_2", "heterograft_3")


mRNA_data_demo <- RNAimport(input = "mRNA", 
                       directory = results_dir,
                       samples = sample_names)
                           
```

<br>

### 3. Import example data 
Import a more comprehensive dataset: 
```{r}
data("mRNA_data")
```

### 3. Differential Analysis of mRNA Population

Undertake differential analysis of sRNA within the experimental design
to explore changes in abundance. The function allows for two methods;
`edgeR` or `DESeq`.

```{r}
## sample conditions in order within dataframe
groups <- c("Selfgraft", "Selfgraft", 
            "Heterograft", "Heterograft")


## Differential analysis of whole dataset: DESeq22 method 
mRNA_DESeq2 <- RNAdifferentialAnalysis(data = mRNA_data,
                                       group = groups,
                                       method = "DESeq2")
```


```{r, eval=FALSE}
# save output as txt file 
write.table(mRNA_DESeq2, "./sRNA_DA_output.txt")

```

Summarise results:

```{r}

RNAsummary(mRNA_DESeq2)

```

How about summarizing the sRNA population which are statistically
significant:

```{r}

RNAsummary(mRNA_DESeq2, alpha=0.05)

```

### 5. Identify Potential Mobile sRNA

Select the putative mobile sRNA clusters using `RNAmobile()`. This
requires supplying the function with a unique identifier of the
rootstock genome. The merging step placed the prefix "B" to the tomato
chromosomes.

```{r}
# define control samples
controls <- c("selfgraft_1", "selfgraft_2")

mobile_mRNA <- RNAmobile(input = "mRNA",
                         data = mRNA_DESeq2, 
                         controls = controls,genome.ID = "B", 
                         task = "keep")
```


```{r, eval=FALSE}
# save output as txt file 
write.table(mobile_mRNA, "./mRNA_mobile_output.txt")

```

<br>

### Output

A data frame where rows represent potential mobile mRNA clusters. The
columns include information on the cluster, individual sample
replicates, and more.

##### Information on the mRNA:

-   `mRNA`: Name of mRNA
-   `Locus`: Genomic loci of mRNA
-   `chr` : Chromosome 
-   `start` : start coordinate
-   `end` : end coordinate
-   `width`: width in nucleotides of regions
-   `CountMean` : Count mean (Calculated by `RNAdifferentialAnalysis()`)
-   `log2FoldChange` : Log2FoldChange--The effect size estimate
-   `pvalue` : P value, the probability under the assumption of no effect or no difference, of obtaining a result equal to or more extreme than what was actually observed
-   `padjusted` : A p-value adjustment
-   `logCPM` : log counts per million, measure of expression level 
-   `comparision.order` : Comparison conditions

##### Information on each sample replicate:

-   `Count` : Number of uniquely aligned reads
-   `FPKM` : Fragments Per Kilobase of transcript per Million
-   `SampleCounts` : Number of replicates which contribute a raw count value >0

# Advanced analysis 

Continuing the analysis from after the importation step in the Quick-Start. 

## Core sRNA analysis
### Quality control
A useful step before analysis is to assess the overall similarity between
sample replicates to understand which samples are similar and different. This
is known as sample level quality control and can help us understand where the 
largest variation is introduced, whether the data meets the expectations and if 
there are outliers. It is expected that between the conditions, the sample 
replicates show enough variation to suggest that the replicates are from 
different groups. Here we undertake sample-level quality control using three 
different methods:

- Distribution of sRNA classes within each sample
- Principal Component Analysis (PCA)
- Distance matrix using hierarchical clustering

The PCA and heatmap both use an unsupervised clustering methods which involves 
an unbiased log2-transformation of the raw counts. This will emphasis the 
clustering to improve visualization. 
<br>

#### Plot the distribution of sRNA classes within each sample
Here, the `RNAdistribution()` function can generate a number of different 
customized plots to represent the number of sRNA clusters within each 
dicercall sRNA class in a sample. In plants, sRNAs are known to be produced 
with length between 21-25 nucleotides, and the lengths signify the sRNA class 
and specific functional role in epigenetic regulation. If there was an 
inconsistent size profile of sRNAs within the cluster, the dicercall is defined
as "N", ie, unclassified. 

Plotting the distribution of dicercall sRNA classes within each replicate can 
support expectation for samples. For instance, in plants, users should expect a 
higher proportion of 24-nt siRNAs along with a smaller number of 20- to 22-nt 
miRNAs. However, if a significant number of sRNA clusters have a dicerCall of 
"N" within a sample. This might suggest the data contains a number of degraded 
RNA fragments, or novel types of sRNA genes. 

The function generation a list object, which stores the plot(s) and the table
of results. 

```{r, echo=FALSE}
cap1 <- "An example facet line graph to show the distribution of sRNA classes within each sample."
cap2 <- "An example facet bar graph to show the distribution of sRNA classes within each sample."
cap3 <- "An example line graph showing all the replicates on a single plot."
```

```{r, message=FALSE}

# plot each replicate as a line, separately, and facet 
sample_distribution_line <- RNAdistribution(sRNA_data,
                                            style = "line",
                                            together = FALSE, 
                                            facet = TRUE,
                                            colour = "darkgreen")

                                            
 # plot each replicate as a bar, separately, and facet 
sample_distribution_bar <- RNAdistribution(sRNA_data,
                                           style = "bar",
                                           facet = TRUE,
                                           colour ="lightblue")

# plot each replicate on a single plot
sample_distribution <- RNAdistribution(sRNA_data,
                                           style = "line",
                                           together = TRUE)

```

Lets view the plots:

```{r, message=FALSE, fig.cap=cap1, fig.show="hold"}
# View plot (only)
sample_distribution_line$plot

```
<br>
```{r, message=FALSE, fig.cap=cap2, fig.show="hold"}
# View plot (only)
sample_distribution_bar$plot

```
<br>
```{r, message=FALSE, fig.cap=cap3, fig.show="hold"}
# View plot
sample_distribution$plot

```

#### PCA

Principal Component Analysis (PCA) is a useful technique to illustrate sample
distance as it emphasizes the variation through the reduction of dimensions in
the data set. Here, we introduce the function `plotSamplePCA()`

```{r, echo=FALSE}
cap4 <-"An example of a PCA, illustracting the sRNA data set sample similarity"

```

```{r, message=FALSE, fig.cap=cap4, fig.show="hold", }

group <- c("Heterograft", "Heterograft", "Heterograft",
            "Selfgraft", "Selfgraft", "Selfgraft")

plotSamplePCA(sRNA_data, group)

```

This PCA is somewhat not what we would expect to see in a real data set. This is
because PC1 is showing the variation between the non-spiked and spiked version 
of the replicate while PC2 shows the natural variation between the replicates. 

It is more likely that in a real sRNA data set, you might expect more or 
less variation between the conditions. For example, analysis of a self-graft 
vs heterograft may show little variation between the conditions. This might be 
expected because there may only be a very small number of endogenous 
mobile/foreign sRNAs that are present in the whole population while the
population of sRNAs present in the destination tissue is expected to be 
largely similar. 
<br>

#### Distance matrix heatmap

Similarly to a PCA plot, the `plotSampleDistance()` function undertakes
hierarchical clustering with an unbiased log transformation to calculate sample
distance illustrated with a distance matrix heatmap.

```{r, echo=FALSE}
cap5 <-"An example of a heatmap,illustrating the sRNA data set sample similarity"

```

```{r ,message=FALSE, fig.cap=cap5, fig.show="hold"}

plotSampleDistance(sRNA_data)

```
<br>


### Define the consensus dicercall
Have a look at the `sRNA_data` object, you will see that for each sample the
sRNA class for a given cluster has been determined (see columns with names 
containing with "DicerCall_") which, in this data, will state a number from 
20-24. This value represent the length in nucleotides of the most abundant 
sRNA within the cluster. For some clusters, there is no particular sRNA which 
is more abundant than another, hence, it is stated as "NA" or "N", which is 
refereed to as being unclassified. 

The `RNAdicercall()` function is used to calculate the consensus dicercall
for each sRNA cluster. This is based of the classification predicted for the 
cluster by each sample within the analysis, described above. There are several
parameters which will alter the output, including the handling of ties and the
method to draw the consensus from. 

Firstly, ties can be handled in two ways, either by selecting one of the tied 
classes at `random` or select the cluster as unclassified through the `exclude`
option. However, when there is a tie between the choice of a class or 
unclassified result the `exclude` option will always select the class choice 
over the unclassified result. The `exclude` option is set as the default.

Secondly, the consensus can be drawn by two different methods. It can either be 
determined based on the dicercall class predictions across all replicates 
or by telling the algorithm to base it's decisions on a specific set of samples. 
As default, it draws the consensus dicercall from all samples in the analysis.

When working with along the mobile sRNA analysis workflow, the function contains 
a specialised parameter which can be utilized where `chimeric=TRUE`, along
with the `genome.ID` and `controls` parameters. In the example below `B_` 
represents the prefix added to the mobile/foreign genotype, which is 
the tomato genome. This helps optimise classification by removal of potential 
mapping errors. 

Plus, if the user utilises the `tidy=TRUE` parameter, this will further alter 
the output as it removes sRNA clusters which have an unclassified (N) consensus 
dicercall. Ultimately in the bid to reduce noise in the data. 


```{r, message=FALSE}

# define consensus, store as a data summary file.
sRNA_data_dicercall <- RNAdicercall(data = sRNA_data, 
                                     chimeric = TRUE, 
                                     genome.ID = "B_", 
                                     controls = c("selfgraft_1", 
                                                  "selfgraft_2", 
                                                  "selfgraft_3"))



```

For the downstream analysis, it can be useful to define distinct groups of 
sRNA classes depending on your organism. For plant samples, it is beneficial to 
select a group of 24-nt and another containing 21/22-nt sRNAs.  


To subset the data, use the `RNAsubset()` function to choose which sRNA 
populations to include: 20-nt, 21-nt, 22-nt, 23-nt, or 24-nt in this data. 
For example, here we select from the population of sRNA the 24nt and also a 
21/22nt population. In this vignette, we do not continue to use these group,
however, it might be preferable to do so in your analysis - at any point. 

```{r, message=FALSE}

# Subset data for analysis: 24-nt sRNAs
sRNA_24 <- RNAsubset(sRNA_data_dicercall, class = 24)

# Subset data for analysis: 21/22-nt sRNAs
sRNA_2122 <- RNAsubset(sRNA_data_dicercall, class = c(21, 22))

```
<br>


#### Plot the consensus dicercall

Similar to before, the `RNAdistriution()` function can be used to visualize the 
distribution of the consensus dicercall classes across the total data set.   

The function can plot the absolute or relative frequency, use argument 
`relative` to adjust the option. It can be beneficial to view the absolute 
frequency as well as the relative to observe whether the data meets your 
expectations.

```{r}

consensus_plot <- RNAdistribution(data = sRNA_data_dicercall,
                                  style = "consensus")
```

```{r, echo=FALSE}
cap6<-"An example of the distribution of small RNA consensus dicer classifications. "

```
Now, view the plot:
```{r, fig.cap=cap6}

# view 
consensus_plot$plot
```
<br>


### Differential expression analysis with `DESeq2` or `edgeR`
Differential expression (DE) analysis is undertaken to identify sRNAs which 
are statistically significant to discover quantitative changes in the abundance
levels between the treatment (heterografts) and the control (self-grafts)
groups. This technique can be undertaken with a variety of tools, in `mobileRNA`
users have the option to use the `DESeq2` or `edgeR` analytical method.

Based on your data, one analytical method might be preferable over another. 
For instance, the applied `DESeq2` method is not appropriate when the experiment 
does not contain replicates (ie. one sample replicate per condition), while
`edgeR` can be used. Here, we have included the recommended practice for `edgeR` 
when the data does not contain replicates. This option can be employed by 
setting a custom dispersion value, see argument `dispersionValue`.

Please note that this step is optional and not a required part of the analysis
for candidate mobile sRNA identification but is required for population changes
difference for both chimeric or non-chimeric systems. 

First lets re-order the dataframe so we are comparing control vs treatment
(ie. Selfgraft vs Heterograft). When the data is imported, it may not be in the
correct order/levels for comparison.  
```{r}
controls <- c("selfgraft_1", "selfgraft_2", "selfgraft_3")

reorder_df <- RNAreorder(sRNA_data_dicercall, controls)
```

```{r DEprep, message = FALSE, warning = FALSE}

# sample conditions in order within dataframe
groups <- c("Selfgraft", "Selfgraft", "Selfgraft", 
            "Heterograft", "Heterograft", "Heterograft")

## Differential analysis of whole dataset: DESeq22 method 
sRNA_DESeq2 <- RNAdifferentialAnalysis(data = reorder_df,
                              group = groups,
                              method = "DESeq2")

```
<br>

We can summarise the results using `RNAsummary()`:

```{r}

RNAsummary(sRNA_DESeq2)

```

How about looking at the sRNA population which are statistically significant:

```{r}

RNAsummary(sRNA_DESeq2, alpha=0.05)

```

#### Save output 
The output dataframe will contain the following columns:

- `Locus`: Genomic location
- `chr`: Name of the chromosome or scaffold
- `start` : Start position of the cluster
- `end` : End position of the cluster
- `Cluster`: Cluster Name

For each sample, the following columns will be present. Where the sample name 
following after the underscore: 

- `DicerCall_` : The size of most abundant small RNA size
- `Count_` : Number of uniquely aligned reads that overlap the locus.
- `RPM_` : Reads per Million
- `FPKM` : Fragments Per Kilobase of transcript per Million
- `MajorRNA_` : RNA sequence of the most abundant sRNA in the cluster

As well as other information generated by the analysis steps including:

- `DicerConsensus` : Consensus dicercall (Calculated by `RNAdicercall()`)
- `DicerCounts` : Number of replicates which contributed to the consensus dicercall sRNA class (Calculated by `RNAdicercall()`)
- `CountMean` :  Count mean (Calculated by `RNAdifferentialAnalysis()`)
- `log2FoldChange` : Log fold change (Calculated by `RNAdifferentialAnalysis()`)
- `pvalue` : p-value (Calculated by `RNAdifferentialAnalysis()`)
- `padjusted` : Adjusted p-value (Calculated by `RNAdifferentialAnalysis()`)
- `logCPM` : Log counts per million (CPM/RPM) (Calculated by `RNAdifferentialAnalysis()`; `edgeR` method)


```{r, eval = FALSE}

write.table(sRNA_DESeq2, "./sRNA_core_dataset.txt")

```

### Explore sRNA population difference between treatment & control
Here, we continue on from the core analysis and look at comparing the
population of sRNAs in the genotype associated with the tissue origin. This 
will be refereed to as the native population. Here we will evaluate how the 
population changes due to the treatment.

As a reminder, the data used here will not yield any results as the 
treatment and control samples contain the exact same population of eggplant 
sRNAs, the only difference in the treatment samples are the spiked tomato 
sRNA clusters. 


#### Differences in sRNA abundance 
When comparing treatment to control conditions, it might be the case that 
the same sRNA clusters are found within both, yet, there could be difference in 
the total abundance of the shared clusters. For instance, for a given sRNA 
cluster the samples in the treatment condition might have a greater abundance 
than the samples in the control condition. 

The statistical analysis calculated the log2FC values for each sRNA cluster by 
comparing the normalised counts between treatment and control. Here, 
a positive log2FC indicates an increased abundance of transcripts for a given 
sRNA cluster in the treatment compared to the control, while negative log2FC 
indicates decreased abundance of transcripts for a given sRNA cluster. The 
statistical significance of the log2FC is determined by the adjusted pvalue.

Here we will filter the data to select sRNA clusters which are statistically 
significant, and then plot the results as a heatmap to compare the conditions. 
```{r, fig.show="hold"}
# summary of statistical sRNA clusters
RNAsummary(sRNA_DESeq2, alpha=0.05)

# select significant 
significant_sRNAs <-  sRNA_DESeq2[sRNA_DESeq2$padjusted < 0.05, ]
```

Plot the results:
<br>
```{r, fig.show="hold"}

p1 <- plotHeatmap(significant_sRNAs, row.names = FALSE)

```


#### Identify gain & loss of sRNA populations
The `RNApopulation()` function can be utilised to identify unique 
sRNA populations found in the treatment or control conditions. This represents 
the sRNA which are gained in the treatment or lost due to the treatment. 

First lets look at the sRNA clusters gained to the treatment condition.
In the chimeric heterografts, we expect that the foreign sRNAs will also be 
selected in this pick-up, therefore, we can use the parameter `genome.ID` to 
remove sRNA cluster related to the foreign genome. 

Here we have used the data set generated from the differential analysis, 
however, you may want to only look at sRNA clusters which are statistically 
significant - generated in the previous section. 


```{r}

# select sRNA clusters only found in treatment & not in the control samples
gained_sRNA <- RNApopulation(data = sRNA_DESeq2, 
                                  conditions = c("heterograft_1", 
                                                 "heterograft_2" , 
                                                 "heterograft_3"),
                                  chimeric = TRUE, 
                                  genome.ID = "B_", 
                                  controls = c("selfgraft_1",
                                               "selfgraft_2", 
                                               "selfgraft_3"))

# look at number of sRNA cluster only found in treatment 
nrow(gained_sRNA)

```


Now, the sRNA clusters lost and only produced in the control condition:
```{r}

# select sRNA clusters only found in control & not in the treatment samples
lost_sRNA <- RNApopulation(data = sRNA_DESeq2, 
                                conditions = c("selfgraft_1", 
                                               "selfgraft_2" , 
                                               "selfgraft_3"))
# look at number of sRNA cluster only found in control  
nrow(lost_sRNA)

```
<br>

The data here can be manipulated in many ways, you may wish to extract
statistically significant sRNA clusters within a population to explore 
further. 

The plotting functions within the package can be used to display these results, 
specifically `RNAdistribution()` and `plotHeatmap()`. Similarly if you 
are comparing several different treatments, a venn diagram could be plotted to 
observe whether any gained or lost populations of sRNA are shared. 

#### Functional analysis of gained & lost sRNA populations 
Now we have identified unique populations produced or not produced in our 
treatment samples compared to our control samples, we can extract the RNA 
sequences to undertaken target prediction and then onward to gene ontology 
enrichment analysis. 

```{r}

gained_sRNA_sequences <- RNAsequences(gained_sRNA)
lost_sRNA_sequences <- RNAsequences(lost_sRNA)

```

Moreover, we can identify genomic features associated with these sRNA clusters 
which are:

* 1 - unique to the treatment and absent in the control ie. gained
* 2 - unique to the controls but absent in the treatment ie. lost

```{r, eval=FALSE}

gained_sRNA_attributes <- RNAattributes(data = gained_sRNA, 
                                        match ="genes",
                            annotation = merged_annotation)

```
<br>
There were zero unique sRNA clusters lost due to the treatment, so this will
generate an error:
```{r, eval=FALSE}


lost_sRNA_attributes <- RNAattributes(data = lost_sRNA, match ="genes",
                            annotation = merged_annotation)
```



## Mobile sRNA analysis 
We identify candidate mobile sRNAs by identifying clusters which are mapped 
to the foreign/mobile genome. These can be isolated using the `RNAmobile()` 
function. Then the user can undertake further steps to assist functional 
analysis. 

In respect to the example data set, we are looking to identify sRNAs traveling 
from the tomato rootstock to the eggplant scion in the heterografts. Hence, this
function will look to select clusters mapped to the tomato genome and remove 
those mapped to the eggplant genome. Previously, the example of the prefix `B_` 
was added to the chromosomes of the tomato genome while prefix `A_` added to 
the eggplant genome. To remove or keep specific clusters, we align this request
with the `"task"` parameter.

Note that the `RNAmobile()` function can take into account statistical values.
If considered the function will filter the putative mobile sRNAs based on the
adjusted p-values. Ultimately selecting only the candidate which abide by the
statistical threshold. The threshold can be changed to make it less stringent by 
using the argument `padj`.Similarly, if the user would prefer to extract the 
mobile sRNA based on the p-value, rather than the adjusted p-values,
a numeric threshold can be set for the argument `p.value`. As default, the 
function does not consider the statistical values and properties of the sRNAs. 
To consider, use `statistical=TRUE`


```{r , message=FALSE}

# vector of control names
control_names <- c("selfgraft_1", "selfgraft_2", "selfgraft_3")


## Identify potential tomato mobile molecules
mobile_sRNA <- RNAmobile(input = "sRNA",
                        data = sRNA_DESeq2, 
                         controls = control_names,
                         genome.ID = "B_",
                         task = "keep", 
                         statistical = FALSE)

## Identify statistically significant potential tomato mobile molecules 
mobile_sRNA_significant <- RNAmobile(input = "sRNA", 
                                     data = sRNA_DESeq2, 
                                     controls = control_names,
                                     genome.ID = "B_",
                                     task = "keep", 
                                     statistical = TRUE) # change this parameter


```
<br>


### Heatmap plots to represent mobile molecules
We can plot our results as a heatmap, which represents the normalised
reads-per-million (RPM) values which have been log transformed.  
<br>

Here we will plot all potential mobile molecules and those which are 
statistically significant:

```{r, echo=FALSE}
cap7 <- "An example heatmap of candidate mobile small RNAs.Where the columns represent the sample replicates and the rows represent the small RNA cluster."

cap8 <- "An example heatmap of candidate mobile small RNAs, which are statistically signifcant (adjusted pvalue < 0.05). Where the columns represent the sample replicates and the rows represent the small RNA cluster."



```

```{r,fig.cap=cap7, fig.show="hold" }

p10 <- plotHeatmap(mobile_sRNA, row.names = FALSE)

```
<br>

```{r,fig.cap=cap8, fig.show="hold"}
p11 <- plotHeatmap(mobile_sRNA_significant, row.names = FALSE)

```

### Save output 

```{r, eval = FALSE}

write.table(mobile_sRNA, "./candidate_mobile_sRNAs.txt")

```

<br>

### Functional analysis 
At this point in the analysis, the user will have produced a dataframe 
containing candidate mobile sRNAs. Now, we can extrapolate information to assist 
the prediction of their targets and role in the biological system. 

We offer three different tools to assist the functional analysis. The first, 
can be used to identify genomic features associated with the sRNA producing 
loci associated to each cluster. This function is known as `RNAattributes()`. 
The second tool does something very similar, it identifies the same overlaps 
but returns a value stating either the absolute or relative number of sRNA 
clusters which over overlap with specific genomic features. This function 
is known as `RNAfeatures()`. Finally, the last tool, called `RNAsequences()` 
calculates the consensus sRNA sequence for each candidate and calculates the
potential target DNA sequence. 


IMPORTANT: Alterations to the genome assemblies by the RNAmergeGenomes()
function must be replicated in the annotations. A merged annotation with the 
same amendments can be created with the function RNAmergeAnnotations(). 
<br>


#### Add genomic attributes to sRNA clusters   
Each sRNA cluster contains coordinates, these can be matches with coordinates in
an annotation file. A match occurs when the cluster is found within the 
coordinates of a feature. If there is a match, the function returns the input 
dataframe with additional fields of information from the annotation file. 

This will enable us to identify the genomic features generating the mobile 
sRNAs. Here we will only be overlapping the data with genes, 
and adding a buffer region of 1 kb upstream and downstream of the each gene. 

```{r, eval=FALSE}

mobile_attributes <- RNAattributes(data = mobile_sRNA, 
                                      match ="genes",
                                      annotation = anno2)

```
<br>

#### Summarise sRNA cluster overlaps with genomic features 
Very similar to before, we can find stricter overlaps between our candidate 
sRNA clusters and genomic features. However, this time we can calculate the 
relative or absolute number of sRNA clusters which are associated to each type 
of feature. These include promoter regions, exon, introns, untranslated regions 
and repeat regions (if, annotation contains repeat regions or supplied 
additionally).The results can either be displayed in the dataframe as an 
absolute value or as a percentage of the total:

NOTE: This function look for the exact matches in the locus (chromosome, 
start and end regions) between the sRNA cluster and the annotation file. 


```{r, eval=FALSE}

mobile_features <- RNAfeatures(data = mobile_sRNA, annotation = anno2)

```
<br>

#### Retrieve RNA sequence from mobile sRNA clusters
To predict the the targets of the mobile sRNA candidates, we need to extract
the RNA sequence. Here, we introduce the `RNAsequences()` function which
extrapolates the consensus RNA sequence and also calculate the complementary 
sequences. It does so by identifying whether the most abundant sRNA is 
consistent across replicates, and if so, it extracts the RNA sequence and 
calculates the RNA & DNA complementary sequences, as well as stating the length 
of the sequence. 

Determining how ties are handling will alter the results. If there is a tie 
between the most abundant sequences within a cluster the user can utilise the 
`duplicates` parameter to choose whether to set the consensus sequence as NA or 
to pick one at random. Similarly, to make the analysis more stringent there is a 
threshold parameter which can be used to set the minimum number of replicates 
required to share the sRNA sequence to count as a match. This is supplied to the 
`match.threshold` argument. 

```{r}

mobile_sequences <- RNAsequences(mobile_sRNA)


```
<br>


#### Save output 
The output consists of a dataframe consisting of 6 columns and where rows 
represent each putative sRNA cluster. The columns include:

- `Cluster`: name of sRNA cluster
- `Match`: whether the RNA sequence is consistent across replicates (either "No", "Yes" or "Duplicate"; where "Duplicate" indicates a tie)
- `Sequence`:  RNA sequence of the most abundant sRNA within a cluster across samples
- `Width`: length of nucleotide sequence
- `Complementary_RNA`: complementary RNA nucleotide sequence
- `Complementary_DNA`: complementary DNA nucleotide sequence


```{r, eval = FALSE}

write.table(mobile_sequences, "./candidate_mobile_sRNA_sequences.txt")

```


Target prediction tools such as `psRNATarget` can be used (Xinbin Dai, 
Zhaohong Zhuang and Patrick X. Zhao (2018). psRNATarget: a plant small RNA 
target analysis server (2017 release). Nucleic Acids Research. 
doi: 10.1093/nar/gky316). 

For a tool like `psRNATarget`, we can manipulate the output of `RNAsequences()` 
to match the input style for target prediction using the following code:

```{r, message=FALSE}
# select the cluster and sequence columns 
sequences <-mobile_sequences %>% select(Cluster, Sequence)

# add prefix, remove row with NA
prefix <- ">"
sequences$Cluster <- paste0(prefix, sequences$Cluster)
sequences <- na.omit(sequences)

# convert
res <- do.call(rbind, lapply(seq(nrow(sequences)), 
                             function(i) t(sequences[i, ])))
```

Save output:
```{r, eval = FALSE, message=FALSE}
# save output 
write.table(res, file ="./mobile_sRNA_sequences.txt",
            row.names = FALSE, col.names = FALSE, quote = FALSE)

```
<br>

Other steps can be take at this stage including alignment of the mobile sRNA 
sequences to identify consensus sequences. For example this can be undertaken 
with the R package `bioseq`. 

```{r, eval = FALSE}

library(bioseq)

mobileRNA_seq <- bioseq::rna(mobile_sequences$Sequence)

bioseq::seq_consensus(mobileRNA_seq)


```



# Additional features

The *mobileRNA* package offers several optional functions to aid analysis. 

## Calculate RPM and Count means for specific samples
This function calculates the RPM mean and Count mean across specific samples.The 
output of the calculation is added as an additional column to the input 
dataframe. 

This can be manipulated to be used before or after identified mobile RNAs. When 
calculating means after identifying mobile molecules, it is recommend to base 
this on the heterograft samples rather than the full dataset 
(self-grafts + heterograft replicates) as all potential mobile sRNAs should have 
zero counts or RPM value in the self-grafts control replicates. By including the 
full dataset in these calculations, the mean values for the mobile molecules 
will be skewed. 

Therefore, depending on your intended output this function could be approached 
in multiple ways. 

```{r}

# calculate mean RPM and mean Counts for heterograft samples
selected_samples <- c("heterograft_1", "heterograft_2", "heterograft_3")
means <- RNAmean(data = sRNA_DESeq2, conditions = selected_samples)


```


# Session information
```{r}
sessionInfo()
```