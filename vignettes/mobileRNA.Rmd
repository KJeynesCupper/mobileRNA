---
title: "mobileRNA: Explore candidate mobile sRNAs & sRNAs population-scale changes"
author: Katie Jeynes-Cupper, Marco Catoni
date: "`r Sys.Date()`"
output:
  BiocStyle::html_document
toc_depth: 3
number_sections: true
theme: united
highlight: tango
fig_width: 7
vignette: >
 %\VignetteIndexEntry{mobileRNA}
 %\VignetteEngine{knitr::rmarkdown}}
 %\VignetteEncoding{UTF-8}
 %\VignettePackage{mobileRNA}
 %\VignetteDepends{dplyr}
 %\usepackage[utf8]{inputenc}
---
<br>
```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  fig.align='center',
  external=TRUE,
  echo=TRUE,
  warning=FALSE,
  comment = "#>"
)

library(dplyr)
```

# Introduction

In plants, systemic signalling is an elaborated molecular system which 
coordinates plant development, integrating and transmitting the information 
perceived from environment to distant organs. An important role in long-distance 
signalling is played by small RNA molecules (sRNAs). The nucleotide length 
of a sRNA helps researches identify the class of sRNA and predict its 
functionality. Micro-RNAs (miRNAs) have a length between 21- and 23-nt, and are
involved in directing translational repression and/or the cleavage of messenger 
RNAs (mRNAs). Whereas, small interfering RNAs (siRNAs) have a length of 24-nt, 
and are involved in the addition of DNA methylation through the RNA-directed
DNA methylation pathway (RdDM) and account for the majority of sRNAs in plants. 
These endogenous sRNAs can be produced in a tissue and then transported 
systemically across the vascular system into recipient organs, where they can 
induce a molecular response and coordinate physiological changes. Plant grafting 
can be utilised to create chimeric plant systems composed of two genotypes. 
For example, grafting can join two different species, such as tomato and 
eggplant, or different plant varieties or accessions. Grafting of horticultural 
crops can lead to favorable traits, such as improved plant vigour or 
architecture, and resistance to stress. sRNAs have been known to move across a 
graft junction, hence, understanding the complex regulatory networks controlled
by sRNAs traveling from different genomes could assist the development of novel 
methods for transferring traits into crops, as alternatives to traditional 
breeding or transgenic approaches.

To identify sRNA population which are mobile or native, analysts currently adopt
a general RNA sequencing pipeline. Several genomic studies have used grafting to 
explore and characterise mobile sRNAs in chimeric systems, however, it is clear 
that there is not a standardised approach.

Here we introduce the R package, `mobileRNA`, a recommended pipeline and 
analysis workflow for the identification of mobile sRNAs and changes in 
static/native sRNA populations in chimeric systems. This has found an 
application in grafted plant systems, where different genotypes are jointed 
together. This workflow is flexible and can also support standard sRNAseq 
analysis between treatment and control conditions. For example, to identify sRNA 
population changes due to the application of a treatment such as cold/heat 
stress or exposure to a pest.

The key aspect of the proposed approach is based on simultaneous alignment on 
two different reference genomes, for differential identification of the origin 
of each of the sequenced RNA molecules. Along with the tools within this R 
package to assist analysis including the characterization of different 
population, visualization of the results, and supports output for functional 
analysis. 

<br>

# Approach

Mobile RNA molecules can travel systemically in plants systems. In grafted 
plants, when different genotypes are used as rootstock and scions, the sequence 
variation between the two genomes involved can be used to discriminate the 
origin of a sequenced RNA molecule. Therefore, if an RNA molecule sequenced 
from one of the grafted partners (scion or rootstock) has found matching the 
genome of the other grafting partner, this could empirically demonstrate it's 
movement across the graft junction.

Most available genomics approaches to implement this analysis are based on RNA 
sequencing, following by alignment on a genotype of reference and post alignment 
screening of genetic variants to identify molecules which have better match for 
the genotype of the grafted partner. These methods have many limitations, which 
might include:

*	High dependency on arbitrary thresholds to determined mapped and unmapped RNAseq reads.
*	Use of additional statistical test to discriminate genetic variations from sequencing noise in post alignment analysis.
*	High false positive rates. 

Here, to circumvents such problems we propose a method inspired by the RNAseq 
analysis of plant hybrids, including an alignment step performed simultaneously 
on both genomes involved. The rational of this approach considers that alignment 
tools already implement an algorithm ideal for identification of the best 
matches (accordingly to set parameters) in a given genome reference, but they do 
not account for potential matches to DNA sequences which are not provided as 
reference. Therefore, the two genomes from all partners involved in the 
chimeric system are merged in a single FASTA file and used as reference for 
the unique alignment with the ShortStack pipeline. A tool specifically designed 
for the genomics analysis of sRNA. In a bid to supply the algorithm with as much 
information as possible to make the best possible predictions and placement of
sequencing reads to each genome. Then, `mobileRNA` will filter clusters which 
uniquely map on the genome of to the other grafting partner involved, which 
would represent the putative mobile RNA molecules.

The summarised workflow is shown below, where it contains a core sRNA analysis
and a mobile sRNA analysis. The core analysis represents the standard workflow 
for the identification of native population difference, for example the sRNA
population difference between treatment and condition samples, or similarly in 
a chimeric system, such as plant grafting, we might want to explore the 
native sRNA population from the sample tissue origin (ie. leaf) which have been 
lost or gained or changes in sRNA abundance. While the mobile sRNA analysis, 
represents the workflow for the identification of putative mobile sRNAs in a 
chimeric system.

As input, the pipeline requires clean small RNA sequencing reads in FASTQ 
format, along with the genome assemblies which represent the genotypes in the
system. 

<br><br>
```{r, fig.align="centre", echo=FALSE,out.width="750", out.height="750",fig.cap="The analysis pipeline for mobileRNA" }

knitr::include_graphics("../man/figures/mobileRNA_graphic_1.png")
```
<br><br><br>

The above figure illustrates workflow, including the merging of the two 
reference which represent the two genotypes in the chimeric system, the
designed alignment steps and the analysis steps. 

The analysis workflow can be completed in a simple 4-step process to identify 
potentially mobile sRNAs and/or to explore the population dynamics. The analysis
can be advanced with the following extra features: 

* Principal component analysis
* Heatmaps 
* Distribution plots
* Statistical analysis with `edgeR` or `DESeq2` methods
* Steps to assist functional analysis. 

The diagram below illustrates the complete workflow using `mobileRNA`, including
essential, optional and plotting functions:

<br><br>
```{r, fig.align="centre", echo=FALSE,out.width="750", out.height="750",fig.cap="The analysis pipeline for mobileRNA" }

knitr::include_graphics("../man/figures/mobileRNA_graphic_2.png")
```
<br>

The analysis approach includes several underlying features to be aware of which 
can alter the final output. When working with a chimeric system, the core steps 
offer the ability to remove mapping errors by comparing control samples to the 
treatment samples. If the genotypes in the chimeric system are fairly distantly 
related, it is unexpected that unique reads aligned to the foreign/mobile
genotype will be found in the control samples. With that in mind, we can assume
sRNA clusters with reads mapped to the foreign/mobile genotype from the control 
samples could be artifacts or mapping errors. Hence, these sRNA clusters are 
removed from the analysis when the parameters are utilsed. Note that, if the 
chimeric system is expected to share some or a high level of similarity it might 
be insightful to the analysis to not remove these sRNA clusters. 

After importing the data into R using `RNAimport()`, the second core 
step is the consensus dicercall classification (see function 
`RNAdicercall()`). For a given sRNA cluster, within each sample a 
sRNA classification is predicted. This information is used to define the 
classification of the cluster based on the consensus across replicates, which is
added as an additional column to the dataframe. As well a further column which 
states the number of replicates which contributed to the consensus class. There 
is a range of parameters to control how these are drawn, making it either 
stringent or loose, which may alter the downstream analysis. These are mainly
related to handling ties. 

The third core step involves the use of differential analysis. It should be 
emphasized that this is an optional step for the identification of mobile sRNA, 
while, for the exploration of population dynamics it is a mandatory step. 
Here we include a single function which can be instructed to undertake 
differential analysis using either the `edgeR` or `DESeq2` method (see function 
`RNAdifferentialAnalysis()`).  The function outputs additional columns 
to your working dataset, including the raw count mean, log2FoldChange, p-value 
and adjusted p-value. 

Here we describe the final steps for each workflow. For mobile sRNA analysis, we 
introduce the `RNAmobile()` function. It contains parameter which can 
either result in stringent or looser outcomes by utilises the number of 
replicates which contributed to the consensus dicercall classification as 
a threshold value. For instance, it would be more stringent to select sRNA 
clusters which were unambiguously classified across condition replicates. While,
for the core sRNA analysis, the final step to identify population changes is to 
locate sRNAs which are unique to the treatment replicate and a set of sRNAs
which are unique to the control replicates. Ultimately, this will identify 
sRNA clusters which were gained or lost due to the treatment in comparison to 
the controls. Moreover, the sRNA abundance explored to identify statistically 
significant changes in abundance between sRNA clusters in the treatment and 
control samples. 

At the end of the basic analysis, the user will have generated a dataframe
where rows represent sRNA clusters and the columns include information on the 
cluster, individual sample replicates, and more: 

#### Information on the cluster:

- `Locus`: Genomic location
- `chr`: Name of the chromosome or scaffold
- `start` : Start position of the cluster
- `end` : End position of the cluster
- `Cluster`: Cluster Name

#### Information on each sample replicate:

- `DicerCall_` : The size of most abundant sRNA 
- `Count_` : Number of uniquely aligned (*e.g.* not multi-mapping) reads that 
overlap the locus.
- `RPM_` : Reads per Million
- `MajorRNA_` : RNA sequence of most abundant sRNA in the cluster

#### Other information

- `DicerConsensus` : Consensus dicercall (Calculated by `RNAdicercall()`)
- `DicerCounts` : Number of replicates which contributed to the consensus dicercall sRNA class (Calculated by `RNAdicercall()`)
- `CountMean` :  Count mean (Calculated by `RNAdifferentialAnalysis()`)
- `log2FoldChange` : Log fold change (Calculated by `RNAdifferentialAnalysis()`)
- `pvalue` : p-value (Calculated by `RNAdifferentialAnalysis()`)
- `padjusted` : Adjusted p-value (Calculated by `RNAdifferentialAnalysis()`)
- `logCPM` : Log counts per million (CPM/RPM) (Calculated by `RNAdifferentialAnalysis()`)


The two different analysis workflows (core & mobile sRNA analysis), subset this
dataframe. The mobile sRNA analysis will generated a further dataframe 
containing only the putative mobile candidates with information as above. The 
user can extract the consensus RNA sequence for each mobile candidate 
(see `RNAsequences()` function) for target prediction analysis. 

If more advanced steps were taken a PCA plot, distance matrix, sRNA class 
distribution plot and heatmap plots could have been generated. Plus, utilsation 
of the functions to assist functional analysis can support the determination 
of the biological implications. 


# Installation

The latest version of `mobileRNA` can be installed via Bioconductor:

```{r,  eval=FALSE, message=FALSE}
if (!require("BiocManager", quietly = TRUE))
    install.packages("BiocManager")

BiocManager::install("mobileRNA")
```


```{r,message=FALSE}

library(mobileRNA)

```


## Installing OS dependancies 

`mobileRNA` works on systems with `R` and `ShortStack` installed. Please 
consider that `ShortStack` is not available for Windows, hence, Windows users 
will either need to opt to use a virtual machine or 
[Windows Subsystem for Linux](https://docs.microsoft.com/en-us/windows/wsl/install-win10)
In either case, both `R` and `ShortStack` will need to be installed and used on 
the Linux side.

Please head to ShortStack to see the recommended installation instructions at 
\link{https://github.com/MikeAxtell/ShortStack#install-using-conda-recommended}
and please ensure its dependencies are stored within the same environment. This
is required for the alignment step. 

Note that if `ShortStack` is not found in R's PATH, or you want to use a 
specific version, you can manually specify the desired directory in R with:

```{r}

options(shortstack_path = "[shortstack path]" )

```



## Example data set

For the following examples, a simulated sRNAseq data set was generated to 
simulate the movement of sRNA molecules in a compatible plant graft system. This
involves Tomato (*Solanium lycopersicum*) as a rootstock to an Eggplant 
(*Solanium melongena*) scion. There are three heterograft replicate, 
where each is an individual tomato replicate spiked with the same random set of 
tomato sRNA clusters. These are known as:

* `heterograft_1`
* `heterograft_2`
* `heterograft_3`  

There are three self-graft replicates, where each is an individual tomato 
replicate without the spiked tomato sRNA clusters. These are:

* `selfgraft_1`
* `selfgraft_2` 
* `selfgraft_3`

The replicates mirror each other where, for instance, `heterograft_1` 
and `selfgraft_1` are the same replicate, either with or without the spiked 
clusters. 

The raw fastq files are stored within `inst/extdata` directory of the
`mobileRNA` package. The data set, called `sRNA_data`, stores a dataframe 
containing the pre-processed data. These can be loaded in the R environment by 
using the following command:

```{r Load, message=FALSE}

data("sRNA_data")

```


## Data organisation
It is recommended to rename your files before beginning to names you wish for 
them to be represented as within the analysis; named in the dataframe and shown 
as labels in plots. 

For example, instead of names such as:

- 1: `sample_1.fq`
- 2: `sample_2.fq`
- 3: `sample_3.fq`
- 4: `sample_4.fq`
- 5: `sample_5.fq`
- 6: `sample_6.fq`

For the example data set included in the package, here we have renamed the
files based on the condition (treatment or control).For the heterografts, where 
the is a eggplant scion and an tomato rootstock:

- 1: `heterograft_1.fq`
- 2: `heterograft_2.fq`
- 3: `heterograft_3.fq`

and for the eggplant self-grafts:

- 4: `selfgraft_1.fq`
- 5: `selfgraft_2.fq`
- 6: `selfgraft_3.fq`
<br>


# Pre-Processing

sRNAseq pre-processing involve trimming, alignment and clustering. Going 
forward, the pipeline assumes that the sRNA-seq samples have met quality control 
standards. Here, within R we will generate the merged genome (if required), and
undertake the alignment of sRNAs sequencing reads using `ShortStack`. 

Please head to `ShortStack` to see the recommended installation instructions at 
\link{https://github.com/MikeAxtell/ShortStack#install-using-conda-recommended}
and please ensure its dependencies are stored within the same environment. Note
that `ShortStack` is not available for Windows systems. 

## Pre-mapping

Here we generate a merged reference genome (FASTA) and a merged annotation 
(GFF). The functions to support this alter the chromosome names in each genome
to support downstream analysis by ensuring the two genomes are distinguishable.  
They remove punctuation and add a prefix to each chromosome name, unique to each
assembly. By default, the pre-fix includes the user-defined string, plus,
an underscore separating the prefix and the pre-existing chromosome name. 
As default, `A` is added to the genome supplied to `genomeA`/`annotationA` and 
`B` is added to the genome supplied to `genomeB`/`annotationB`. These can be 
customized to the users preference.

*It is important that the same alterations are made to each genome in the merged
files for downstream analysis - otherwise the annotation file will not align 
with the chromosome names used for alignment.*
<br>

### Merging Genome Assemblies

Firstly, lets load the examples:
<br>
```{r}

library(BiocFileCache)
cache_dir <- tools::R_user_dir("mobileRNA", which = "cache")
cache <- BiocFileCache(cache_dir)

# Construct URL to example FASTA files
url_remote <- "https://github.com/KJeynesCupper/assemblies/raw/main/"

fasta_1_url <- file.path(url_remote, "chr12_Eggplant_V4.1.fa.gz")
fasta_2_url <- file.path(url_remote,"chr2_S_lycopersicum_chromosomes.4.00.fa.gz")

# Download example FASTA files and add them to cache
fasta_1 <- bfcrpath(cache, fasta_1_url)
fasta_2 <- bfcrpath(cache, fasta_2_url)

```

Here we merge the two reference genomes into a merged genome using the
`RNAmergeGenomes()` function. 
<br>
```{r, eval = FALSE}

# define temporary output directory 
output_assembly_file <- tempfile("merged_annotation", fileext = ".fa")

# merge assemblies into a single file
RNAmergeGenomes(genomeA = fasta_1,
               genomeB = fasta_2,
               out_dir = output_assembly_file)

```
<br>

## Merging genome annotations

Now, repeat for the genome annotations (GFF) - this is required for downstream 
analysis, for example to identify genomic features which overlap the sRNA 
producing loci. 

### Merge genomic features annotations
Firstly, lets load the examples:
<br>
```{r}
# Construct URL to example GFF files
anno1_url <- file.path(url_remote,"chr12_Eggplant_V4.1_function_IPR_final.gff")
anno2_url <- file.path(url_remote, "chr2_ITAG4.0_gene_models.gff")

# Download example GFF files and add them to cache
anno1 <- bfcrpath(cache, anno1_url)
anno2 <- bfcrpath(cache, anno2_url)

```

Here, we merge the GFF annotation files using the `RNAmergeAnnotations()`
function.
<br>
```{r, eval = FALSE}
# define temporary output directory 
output_annotation_file <- tempfile("merged_annotation", fileext = ".gff3")

# merge annotation files into a single file
merged_annotation <- RNAmergeAnnotations(annotationA = anno1,
                                         annotationB = anno2,
                                         out_dir = output_annotation_file)

```

### Merge annotations storing repetitive regions:

Firstly, lets load the examples:
<br>
```{r}

# Construct URL to example GFF files
repeats1_url <-file.path(url_remote,"chr12_Eggplant_V4.1_repeats.gff3")
repeats2_url <-file.path(url_remote,"chr2_ITAG4.0_REPET_repeats_aggressive.gff")

# Download example GFF files and add them to cache
repeats1 <- bfcrpath(cache, repeats1_url)
repeats2 <- bfcrpath(cache, repeats2_url)

```

Here, we merge the GFF annotation files using the `RNAmergeAnnotations()`
function.
<br>
```{r, eval = FALSE}
# define temporary output directory 
output_annotation_file <- tempfile("merged_annotation", fileext = ".gff3")

# merge annotation files into a single file
merged_repeatregions <-RNAmergeAnnotations(annotationA = repeats1,
                                           annotationB = repeats2,
                                           out_dir = output_annotation_file)

```

## Mapping 
Here we will align our samples containing small RNA sequencing reads to the 
merged genome assembly created earlier. 

The `sRNAmapper()` function requires three core inputs:

* 1 - The directory containing the FASTQ files for all the samples in the analysis 
* 2 - The directory to store the output 
* 3 - The directory to genome assembly file (.fa or .fasta)

The function invokes a system command to  `ShortStack`; an application which 
employs bowtie mapping and performs comprehensive de novo annotation and 
quantification of sRNA genes. The function first undertakes de novo sRNA
cluster detection and then quantification of sRNA genes. The function outputs
a plain text file (`locifile.txt`) and two directories (`1_map` and `2_map`). 
The plain text file contains the de novo sRNA clusters detected across the 
entire experimental design, and the directories contain one folder per sample. 
Each sample folder stored the `ShortStack` output reports which report on 
several parameters of each sRNA gene annotation. As default, the function only 
retains the most important reports required for downstream analysis which will 
be imported into R in the analysis steps of the vignette. 

Note that if `ShortStack` is not found in R's PATH, or you want to use a 
specific version, you can manually specify the desired directory in R with:

```{r,  eval=FALSE}

options(shortstack_path = "[shortstack path]" )

```

Then, align samples in the directory to the merged genome: 

```{r,eval=FALSE}
samples <- file.path(system.file("extdata",package="mobileRNA"))

output_location <- tempdir()

sRNAmapper(input_files_dir = samples, 
           output_dir = output_location, 
           genomefile = output_assembly_file)

```


# Core sRNA Analysis
Here, we will analyse the output reports from the alignment data to identify 
candidate mobile sRNA molecules, as well as identifying changes in the native 
sRNA population, specifically those which have been gained and lost due to the 
treatment in comparison to the control and those statistically more or less
abundant. 
<br>

## Import data
The sRNAseq mapping steps generate a directory (`2_map`) containing a folder 
for each sample storing the mapping reports. Here, we will use the `RNAimport()` 
function to import the report file called `Results.txt` for each sample into R. 
This will generate a dataframe where rows represent sRNA clusters and 
contains the following columns: 

- `Locus`: Genomic location
- `chr`: Name of the chromosome or scaffold
- `start` : Start position of the cluster
- `end` : End position of the cluster
- `Cluster`: Cluster Name

For each sample, the following columns will be present. Where the sample name 
following after the underscore: 

- `DicerCall_` : The size of most abundant small RNA size
- `Count_` : Number of uniquely aligned reads that overlap the locus.
- `RPM_` : Reads per Million
- `MajorRNA_` : RNA sequence of the most abundant sRNA in the cluster


The function requires the directory storing the output folders (ie. the path to 
the 2_map folder generated by the `sRNAmapper()` function), as well as a vector 
containing the names of each sample to include in the import. It is critical 
that the names provided correspond exactly to the folder names in the directory. 


```{r, eval = FALSE, message=FALSE}

## state file path to mapping report directory
results_dir <- file.path(output_location, "2_map")

## state names of folders ie. samples
sample_names <- c("heterograft_1","heterograft_2", "heterograft_3",
                  "selfgraft_1", "selfgraft_2", "selfgraft_3")

# run importation
sRNA_data <- RNAimport(input = "sRNA",
                       directory = results_dir,
                       samples = sample_names)

```


## Quality control
A useful step before analysis is to assess the overall similarity between
sample replicates to understand which samples are similar and different. This
is known as sample level quality control and can help us understand where the 
largest variation is introduced, whether the data meets the expectations and if 
there are outliers. It is expected that between the conditions, the sample 
replicates show enough variation to suggest that the replicates are from 
different groups. Here we undertake sample-level quality control using three 
different methods:

- Distribution of sRNA classes within each sample
- Principal Component Analysis (PCA)
- Distance matrix using hierarchical clustering

The PCA and heatmap both use an unsupervised clustering methods which involves 
an unbiased log2-transformation of the raw counts. This will emphasis the 
clustering to improve visualization. 
<br>

### Plot the distribution of sRNA classes within each sample
Here, the `RNAdistribution()` function can generate a number of different 
customized plots to represent the number of sRNA clusters within each 
dicercall sRNA class in a sample. In plants, sRNAs are known to be produced 
with length between 21-25 nucleotides, and the lengths signify the sRNA class 
and specific functional role in epigenetic regulation. If there was an 
inconsistent size profile of sRNAs within the cluster, the dicercall is defined
as "N", ie, unclassified. 

Plotting the distribution of dicercall sRNA classes within each replicate can 
support expectation for samples. For instance, in plants, users should expect a 
higher proportion of 24-nt siRNAs along with a smaller number of 20- to 22-nt 
miRNAs. However, if a significant number of sRNA clusters have a dicerCall of 
"N" within a sample. This might suggest the data contains a number of degraded 
RNA fragments, or novel types of sRNA genes. 

The results can be plotted as either a bar chart (`style = "bar"`)  or a 
line graph (`style = "line"`) for each sample and can be shown in a facet
(`facet = TRUE`) or in as a single line graph, where each line represents a
sample (`together=TRUE`). Alternatively, the results can be plotted individually
for each sample in either format (`together = FALSE`).

The function generation a list object, which stores the plot(s) and the table
of results. 

```{r, echo=FALSE}
cap1 <- "An example facet line graph to show the distribution of sRNA classes within each sample."
cap2 <- "An example facet bar graph to show the distribution of sRNA classes within each sample."
cap3 <- "An example line graph showing all the replicates on a single plot."
```

```{r, message=FALSE}

# plot each replicate as a line, separately, and facet 
sample_distribution_line <- RNAdistribution(sRNA_data,
                                            style = "line",
                                            together = FALSE, 
                                            facet = TRUE,
                                            colour = "darkgreen")

                                            
 # plot each replicate as a bar, separately, and facet 
sample_distribution_bar <- RNAdistribution(sRNA_data,
                                           style = "bar",
                                           facet = TRUE,
                                           colour ="lightblue")

# plot each replicate on a single plot
sample_distribution <- RNAdistribution(sRNA_data,
                                           style = "line",
                                           together = TRUE)

```

Lets view the plots:

```{r, message=FALSE, fig.cap=cap1, fig.show="hold"}
# View plot (only)
sample_distribution_line$plot

```
<br>
```{r, message=FALSE, fig.cap=cap2, fig.show="hold"}
# View plot (only)
sample_distribution_bar$plot

```
<br>
```{r, message=FALSE, fig.cap=cap3, fig.show="hold"}
# View plot
sample_distribution$plot

```

### PCA

Principal Component Analysis (PCA) is a useful technique to illustrate sample
distance as it emphasizes the variation through the reduction of dimensions in
the data set. Here, we introduce the function `plotSamplePCA()`

```{r, echo=FALSE}
cap4 <-"An example of a PCA, illustracting the sRNA data set sample similarity"

```

```{r, message=FALSE, fig.cap=cap4, fig.show="hold", }

group <- c("Heterograft", "Heterograft", "Heterograft",
            "Selfgraft", "Selfgraft", "Selfgraft")

plotSamplePCA(sRNA_data, group)

```

This PCA is somewhat not what we would expect to see in a real data set. This is
because PC1 is showing the variation between the non-spiked and spiked version 
of the replicate while PC2 shows the natural variation between the replicates. 

It is more likely that in a real sRNA data set, you might expect more or 
less variation between the conditions. For example, analysis of a self-graft 
vs heterograft may show little variation between the conditions. This might be 
expected because there may only be a very small number of endogenous 
mobile/foreign sRNAs that are present in the whole population while the
population of sRNAs present in the destination tissue is expected to be 
largely similar. 
<br>

### Distance matrix heatmap

Similarly to a PCA plot, the `plotSampleDistance()` function undertakes
hierarchical clustering with an unbiased log transformation to calculate sample
distance illustrated with a distance matrix heatmap.

```{r, echo=FALSE}
cap5 <-"An example of a heatmap,illustrating the sRNA data set sample similarity"

```

```{r ,message=FALSE, fig.cap=cap5, fig.show="hold"}

plotSampleDistance(sRNA_data)

```
<br>


## Define the consensus dicercall
Have a look at the `sRNA_data` object, you will see that for each sample the
sRNA class for a given cluster has been determined (see columns with names 
containing with "DicerCall_") which, in this data, will state a number from 
20-24. This value represent the length in nucleotides of the most abundant 
sRNA within the cluster. For some clusters, there is no particular sRNA which 
is more abundant than another, hence, it is stated as "NA" or "N", which is 
refereed to as being unclassified. 

The `RNAdicercall()` function is used to calculate the consensus dicercall
for each sRNA cluster. This is based of the classification predicted for the 
cluster by each sample within the analysis, described above. There are several
parameters which will alter the output, including the handling of ties and the
method to draw the consensus from. 

Firstly, ties can be handled in two ways, either by selecting one of the tied 
classes at `random` or select the cluster as unclassified through the `exclude`
option. However, when there is a tie between the choice of a class or 
unclassified result the `exclude` option will always select the class choice 
over the unclassified result. The `exclude` option is set as the default.

Secondly, the consensus can be drawn by two different methods. It can either be 
determined based on the dicercall class predictions across all replicates 
or by telling the algorithm to base it's decisions on a specific set of samples. 
As default, it draws the consensus dicercall from all samples in the analysis.

When working with along the mobile sRNA analysis workflow, the function contains 
a specialised parameter which can be utilized where `chimeric=TRUE`, along
with the `genome.ID` and `controls` parameters. In the example below `B_` 
represents the prefix added to the mobile/foreign genotype, which is 
the tomato genome. This helps optimise classification by removal of potential 
mapping errors. 

Plus, if the user utilises the `tidy=TRUE` parameter, this will further alter 
the output as it removes sRNA clusters which have an unclassified (N) consensus 
dicercall. Ultimately in the bid to reduce noise in the data. 


```{r, message=FALSE}

# define consensus, store as a data summary file.
sRNA_data_consensus <- RNAdicercall(data = sRNA_data, 
                                     chimeric = TRUE, 
                                     genome.ID = "B_", 
                                     controls = c("selfgraft_1", 
                                                  "selfgraft_2", 
                                                  "selfgraft_3"))



```

For the downstream analysis, it can be useful to define distinct groups of 
sRNA classes depending on your organism. For plant samples, it is beneficial to 
select a group of 24-nt and another containing 21/22-nt sRNAs.  


To subset the data, use the `RNAsubset()` function to choose which sRNA 
populations to include: 20-nt, 21-nt, 22-nt, 23-nt, or 24-nt in this data. 
For example, here we select from the population of sRNA the 24nt and also a 
21/22nt population. In this vignette, we do not continue to use these group,
however, it might be preferable to do so in your analysis - at any point. 

```{r, message=FALSE}

# Subset data for analysis: 24-nt sRNAs
sRNA_24 <- RNAsubset(sRNA_data_consensus, class = 24)

# Subset data for analysis: 21/22-nt sRNAs
sRNA_2122 <- RNAsubset(sRNA_data_consensus, class = c(21, 22))

```
<br>


### Plot the consensus dicercall

Similar to before, the `RNAdistriution()` function can be used to visualize the 
distribution of the consensus dicercall classes across the total data set.   

The function can plot the absolute or relative frequency, use argument 
`relative` to adjust the option. It can be beneficial to view the absolute 
frequency as well as the relative to observe whether the data meets your 
expectations.

```{r}

consensus_plot <- RNAdistribution(data = sRNA_data_consensus,
                                  style = "consensus")
```

```{r, echo=FALSE}
cap6<-"An example of the distribution of small RNA consensus dicer classifications. "

```
Now, view the plot:
```{r, fig.cap=cap6}

# view 
consensus_plot$plot
```
<br>


## Differential expression analysis with `DESeq2` or `edgeR`
Differential expression (DE) analysis is undertaken to identify sRNAs which 
are statistically significant to discover quantitative changes in the abundance
levels between the treatment (heterografts) and the control (self-grafts)
groups. This technique can be undertaken with a variety of tools, in `mobileRNA`
users have the option to use the `DESeq2` or `edgeR` analytical method.

Based on your data, one analytical method might be preferable over another. 
For instance, the applied `DESeq2` method is not appropriate when the experiment 
does not contain replicates (ie. one sample replicate per condition), while
`edgeR` can be used. Here, we have included the recommended practice for `edgeR` 
when the data does not contain replicates. This option can be employed by 
setting a custom dispersion value, see argument `dispersionValue`.

Please note that this step is optional and not a required part of the analysis
for candidate mobile sRNA identification but is required for population changes
difference for both chimeric or non-chimeric systems. 

First lets re-order the dataframe so we are comparing control vs treatment
(ie. Selfgraft vs Heterograft). When the data is imported, it may not be in the
correct order/levels for comparison.  
```{r}
controls <- c("selfgraft_1", "selfgraft_2", "selfgraft_3")

reorder_df <- RNAreorder(sRNA_data_consensus, controls)
```

```{r DEprep, message = FALSE, warning = FALSE}

# sample conditions in order within dataframe
groups <- c("Selfgraft", "Selfgraft", "Selfgraft", 
            "Heterograft", "Heterograft", "Heterograft")

## Differential analysis of whole dataset: DESeq22 method 
sRNA_DESeq2 <- RNAdifferentialAnalysis(data = reorder_df,
                              group = groups,
                              method = "DESeq2")

```
<br>

We can summarise the results using `RNAsummary()`:

```{r}

RNAsummary(sRNA_DESeq2)

```

How about looking at the sRNA population which are statistically significant:

```{r}

RNAsummary(sRNA_DESeq2, alpha=0.05)

```

### Save output 
The output dataframe will contain the following columns:

- `Locus`: Genomic location
- `chr`: Name of the chromosome or scaffold
- `start` : Start position of the cluster
- `end` : End position of the cluster
- `Cluster`: Cluster Name

For each sample, the following columns will be present. Where the sample name 
following after the underscore: 

- `DicerCall_` : The size of most abundant small RNA size
- `Count_` : Number of uniquely aligned reads that overlap the locus.
- `RPM_` : Reads per Million
- `MajorRNA_` : RNA sequence of the most abundant sRNA in the cluster

As well as other information generated by the analysis steps including:

- `DicerConsensus` : Consensus dicercall (Calculated by `RNAdicercall()`)
- `DicerCounts` : Number of replicates which contributed to the consensus dicercall sRNA class (Calculated by `RNAdicercall()`)
- `CountMean` :  Count mean (Calculated by `RNAdifferentialAnalysis()`)
- `log2FoldChange` : Log fold change (Calculated by `RNAdifferentialAnalysis()`)
- `pvalue` : p-value (Calculated by `RNAdifferentialAnalysis()`)
- `padjusted` : Adjusted p-value (Calculated by `RNAdifferentialAnalysis()`)
- `logCPM` : Log counts per million (CPM/RPM) (Calculated by `RNAdifferentialAnalysis()`; `edgeR` method)


```{r, eval = FALSE}

write.table(sRNA_DESeq2, "./sRNA_dataset.txt")

```


# Mobile sRNA analysis 
We identify candidate mobile sRNAs by identifying clusters which are mapped 
to the foreign/mobile genome. These can be isolated using the `RNAmobile()` 
function. Then the user can undertake further steps to assist functional 
analysis. 

In respect to the example data set, we are looking to identify sRNAs traveling 
from the tomato rootstock to the eggplant scion in the heterografts. Hence, this
function will look to select clusters mapped to the tomato genome and remove 
those mapped to the eggplant genome. Previously, the example of the prefix `B_` 
was added to the chromosomes of the tomato genome while prefix `A_` added to 
the eggplant genome. To remove or keep specific clusters, we align this request
with the `"task"` parameter.

Note that the `RNAmobile()` function can take into account statistical values.
If considered the function will filter the putative mobile sRNAs based on the
adjusted p-values. Ultimately selecting only the candidate which abide by the
statistical threshold. The threshold can be changed to make it less stringent by 
using the argument `padj`.Similarly, if the user would prefer to extract the 
mobile sRNA based on the p-value, rather than the adjusted p-values,
a numeric threshold can be set for the argument `p.value`. As default, the 
function does not consider the statistical values and properties of the sRNAs. 
To consider, use `statistical=TRUE`


```{r , message=FALSE}

# vector of control names
control_names <- c("selfgraft_1", "selfgraft_2", "selfgraft_3")


## Identify potential tomato mobile molecules
mobile_sRNA <- RNAmobile(data = sRNA_DESeq2, 
                         controls = control_names,
                         genome.ID = "B_",
                         task = "keep", 
                         statistical = FALSE)

## Identify statistically significant potential tomato mobile molecules 
mobile_sRNA_significant <- RNAmobile(data = sRNA_DESeq2, 
                         controls = control_names,
                         genome.ID = "B_",
                         task = "keep", 
                         statistical = TRUE) # change this parameter


```
<br>


### Heatmap plots to represent mobile molecules
We can plot our results as a heatmap, which represents the normalised
reads-per-million (RPM) values which have been log transformed.  
<br>

Here we will plot all potential mobile molecules and those which are 
statistically significant:

```{r, echo=FALSE}
cap7 <- "An example heatmap of candidate mobile small RNAs.Where the columns represent the sample replicates and the rows represent the small RNA cluster."

cap8 <- "An example heatmap of candidate mobile small RNAs, which are statistically signifcant (adjusted pvalue < 0.05). Where the columns represent the sample replicates and the rows represent the small RNA cluster."



```

```{r,fig.cap=cap7, fig.show="hold" }

p10 <- plotHeatmap(mobile_sRNA, row.names = FALSE)

```
<br>

```{r,fig.cap=cap8, fig.show="hold"}
p11 <- plotHeatmap(mobile_sRNA_significant, row.names = FALSE)

```

### Save output 

The output dataframe containing the mobile candidates will contain the following 
columns:

- `Locus`: Genomic location
- `chr`: Name of the chromosome or scaffold
- `start` : Start position of the cluster
- `end` : End position of the cluster
- `Cluster`: Cluster Name

For each sample, the following columns will be present. Where the sample name 
following after the underscore: 

- `DicerCall_` : The size of most abundant small RNA size
- `Count_` : Number of uniquely aligned reads that overlap the locus.
- `RPM_` : Reads per Million
- `MajorRNA_` : RNA sequence of the most abundant sRNA in the cluster

As well as other information generated by the analysis steps including:

- `DicerConsensus` : Consensus dicercall (Calculated by `RNAdicercall()`)
- `DicerCounts` : Number of replicates which contributed to the consensus dicercall sRNA class (Calculated by `RNAdicercall()`)
- `CountMean` :  Count mean (Calculated by `RNAdifferentialAnalysis()`)
- `log2FoldChange` : Log fold change (Calculated by `RNAdifferentialAnalysis()`)
- `pvalue` : p-value (Calculated by `RNAdifferentialAnalysis()`)
- `padjusted` : Adjusted p-value (Calculated by `RNAdifferentialAnalysis()`)
- `logCPM` : Log counts per million (CPM/RPM) (Calculated by `RNAdifferentialAnalysis()`; `edgeR` method)


```{r, eval = FALSE}

write.table(mobile_sRNA, "./candidate_mobile_sRNAs.txt")

```

<br>

## Functional analysis 
At this point in the analysis, the user will have produced a dataframe 
containing candidate mobile sRNAs. Now, we can extrapolate information to assist 
the prediction of their targets and role in the biological system. 

We offer three different tools to assist the functional analysis. The first, 
can be used to identify genomic features associated with the sRNA producing 
loci associated to each cluster. This function is known as `RNAattributes()`. 
The second tool does something very similar, it identifies the same overlaps 
but returns a value stating either the absolute or relative number of sRNA 
clusters which over overlap with specific genomic features. This function 
is known as `RNAfeatures()`. Finally, the last tool, called `RNAsequences()` 
calculates the consensus sRNA sequence for each candidate and calculates the
potential target DNA sequence. 


IMPORTANT: Alterations to the genome assemblies by the RNAmergeGenomes()
function must be replicated in the annotations. A merged annotation with the 
same amendments can be created with the function RNAmergeAnnotations(). 
<br>


### Add genomic attributes to sRNA clusters   
Each sRNA cluster contains coordinates, these can be matches with coordinates in
an annotation file. A match occurs when the cluster is found within the 
coordinates of a feature. If there is a match, the function returns the input 
dataframe with additional fields of information from the annotation file. 

This will enable us to identify the genomic features generating the mobile 
sRNAs. Here we will only be overlapping the data with genes, 
and adding a buffer region of 1 kb upstream and downstream of the each gene. 

```{r}

mobile_attributes <- RNAattributes(data = mobile_sRNA, 
                                      match ="genes",
                                      annotation = merged_annotation)

```
<br>

### Summarise sRNA cluster overlaps with genomic features 
Very similar to before, we can find stricter overlaps between our candidate 
sRNA clusters and genomic features. However, this time we can calculate the 
relative or absolute number of sRNA clusters which are associated to each type 
of feature. These include promoter regions, exon, introns, untranslated regions 
and repeat regions.The results can either be displayed in the dataframe as an
absolute value or as a percentage of the total:

NOTE: This function look for the exact matches in the locus (chromosome, 
start and end regions) between the sRNA cluster and the annotation file.  

```{r}

mobile_features <- RNAfeatures(data = mobile_sRNA,
                            annotation = merged_annotation, 
                            repeats = merged_repeatregions)

```
<br>

### Retrieve RNA sequence from mobile sRNA clusters
To predict the the targets of the mobile sRNA candidates, we need to extract
the RNA sequence. Here, we introduce the `RNAsequences()` function which
extrapolates the consensus RNA sequence and also calculate the complementary 
sequences. It does so by identifying whether the most abundant sRNA is 
consistent across replicates, and if so, it extracts the RNA sequence and 
calculates the RNA & DNA complementary sequences, as well as stating the length 
of the sequence. 

Determining how ties are handling will alter the results. If there is a tie 
between the most abundant sequences within a cluster the user can utilise the 
`duplicates` parameter to choose whether to set the consensus sequence as NA or 
to pick one at random. Similarly, to make the analysis more stringent there is a 
threshold parameter which can be used to set the minimum number of replicates 
required to share the sRNA sequence to count as a match. This is supplied to the 
`match.threshold` argument. 

```{r}

mobile_sequences <- RNAsequences(mobile_sRNA)


```
<br>


### Save output 
The output consists of a dataframe consisting of 6 columns and where rows 
represent each putative sRNA cluster. The columns include:

- `Cluster`: name of sRNA cluster
- `Match`: whether the RNA sequence is consistent across replicates (either "No", "Yes" or "Duplicate"; where "Duplicate" indicates a tie)
- `Sequence`:  RNA sequence of the most abundant sRNA within a cluster across samples
- `Width`: length of nucleotide sequence
- `Complementary_RNA`: complementary RNA nucleotide sequence
- `Complementary_DNA`: complementary DNA nucleotide sequence


```{r, eval = FALSE}

write.table(mobile_sequences, "./candidate_mobile_sRNA_sequences.txt")

```


Target prediction tools such as `psRNATarget` can be used (Xinbin Dai, 
Zhaohong Zhuang and Patrick X. Zhao (2018). psRNATarget: a plant small RNA 
target analysis server (2017 release). Nucleic Acids Research. 
doi: 10.1093/nar/gky316). 

For a tool like `psRNATarget`, we can manipulate the output of `RNAsequences()` 
to match the input style for target prediction using the following code:

```{r, message=FALSE}
library(dplyr)
# select the cluster and sequence columns 
sequences <-mobile_sequences %>% select(Cluster, Sequence)

# add prefix, remove row with NA
prefix <- ">"
sequences$Cluster <- paste0(prefix, sequences$Cluster)
sequences <- na.omit(sequences)

# convert
res <- do.call(rbind, lapply(seq(nrow(sequences)), 
                             function(i) t(sequences[i, ])))
```

Save output:
```{r, eval = FALSE, message=FALSE}
# save output 
write.table(res, file ="./mobile_sRNA_sequences.txt",
            row.names = FALSE, col.names = FALSE, quote = FALSE)

```
<br>

Other steps can be take at this stage including alignment of the mobile sRNA 
sequences to identify consensus sequences. For example this can be undertaken 
with the R package `bioseq`. 

```{r}

library(bioseq)

mobileRNA_seq <- bioseq::rna(mobile_sequences$Sequence)

bioseq::seq_consensus(mobileRNA_seq)


```


# Continued, Core sRNA analysis
## Explore sRNA population difference between treatment & control
Here, we continue on from the core analysis and look at comparing the
population of sRNAs in the genotype associated with the tissue origin. This 
will be refereed to as the native population. Here we will evaluate how the 
population changes due to the treatment.

As a reminder, the data used here will not yield any results as the 
treatment and control samples contain the exact same population of eggplant 
sRNAs, the only difference in the treatment samples are the spiked tomato 
sRNA clusters. 


### Differences in sRNA abundance 
When comparing treatment to control conditions, it might be the case that 
the same sRNA clusters are found within both, yet, there could be difference in 
the total abundance of the shared clusters. For instance, for a given sRNA 
cluster the samples in the treatment condition might have a greater abundance 
than the samples in the control condition. 

The statistical analysis calculated the log2FC values for each sRNA cluster by 
comparing the normalised counts between treatment and control. Here, 
a positive log2FC indicates an increased abundance of transcripts for a given 
sRNA cluster in the treatment compared to the control, while negative log2FC 
indicates decreased abundance of transcripts for a given sRNA cluster. The 
statistical significance of the log2FC is determined by the adjusted pvalue.

Here we will filter the data to select sRNA clusters which are statistically 
significant, and then plot the results as a heatmap to compare the conditions. 
```{r, fig.show="hold"}
# summary of statistical sRNA clusters
RNAsummary(sRNA_DESeq2, alpha=0.05)

# select significant 
significant_sRNAs <-  sRNA_DESeq2[sRNA_DESeq2$padjusted < 0.05, ]
```

Plot the results:
<br>
```{r, fig.show="hold"}

p1 <- plotHeatmap(significant_sRNAs, row.names = FALSE)

```


### Identify gain & loss of sRNA populations
The `RNApopulation()` function can be utilised to identify unique 
sRNA populations found in the treatment or control conditions. This represents 
the sRNA which are gained in the treatment or lost due to the treatment. 

First lets look at the sRNA clusters gained to the treatment condition.
In the chimeric heterografts, we expect that the foreign sRNAs will also be 
selected in this pick-up, therefore, we can use the parameter `genome.ID` to 
remove sRNA cluster related to the foreign genome. 

Here we have used the data set generated from the differential analysis, 
however, you may want to only look at sRNA clusters which are statistically 
significant - generated in the previous section. 


```{r}

# select sRNA clusters only found in treatment & not in the control samples
gained_sRNA <- RNApopulation(data = sRNA_DESeq2, 
                                  conditions = c("heterograft_1", 
                                                 "heterograft_2" , 
                                                 "heterograft_3"),
                                  chimeric = TRUE, 
                                  genome.ID = "B_", 
                                  controls = c("selfgraft_1",
                                               "selfgraft_2", 
                                               "selfgraft_3"))

# look at number of sRNA cluster only found in treatment 
nrow(gained_sRNA)

```


Now, the sRNA clusters lost and only produced in the control condition:
```{r}

# select sRNA clusters only found in control & not in the treatment samples
lost_sRNA <- RNApopulation(data = sRNA_DESeq2, 
                                conditions = c("selfgraft_1", 
                                               "selfgraft_2" , 
                                               "selfgraft_3"))
# look at number of sRNA cluster only found in control  
nrow(lost_sRNA)

```
<br>

The data here can be manipulated in many ways, you may wish to extract
statistically significant sRNA clusters within a population to explore 
further. 

The plotting functions within the package can be used to display these results, 
specifically `RNAdistribution()` and `plotHeatmap()`. Similarly if you 
are comparing several different treatments, a venn diagram could be plotted to 
observe whether any gained or lost populations of sRNA are shared. 

### Functional analysis of gained & lost sRNA populations 
Now we have identified unique populations produced or not produced in our 
treatment samples compared to our control samples, we can extract the RNA 
sequences to undertaken target prediction and then onward to gene ontology 
enrichment analysis. 

```{r}

gained_sRNA_sequences <- RNAsequences(gained_sRNA)
lost_sRNA_sequences <- RNAsequences(lost_sRNA)

```

Moreover, we can identify genomic features associated with these sRNA clusters 
which are:

* 1 - unique to the treatment and absent in the control ie. gained
* 2 - unique to the controls but absent in the treatment ie. lost

```{r}

gained_sRNA_attributes <- RNAattributes(data = gained_sRNA, match ="genes",
                            annotation = merged_annotation)


lost_sRNA_attributes <- RNAattributes(data = lost_sRNA, match ="genes",
                            annotation = merged_annotation)
```
<br>

# Additional features

The *mobileRNA* package offers several optional functions to aid analysis. 
This includes a function to calculate the mean RPM and counts across
specific samples and also calculate the overlap between genomic features and
sRNA clusters.

<br>

## Calculate RPM and Count means for specific samples
This function calculates the RPM mean and Count mean across specific samples.The 
output of the calculation is added as an additional column to the input 
dataframe. 

This can be manipulated to be used before or after identified mobile RNAs. When 
calculating means after identifying mobile molecules, it is recommend to base 
this on the heterograft samples rather than the full dataset 
(self-grafts + heterograft replicates) as all potential mobile sRNAs should have 
zero counts or RPM value in the self-grafts control replicates. By including the 
full dataset in these calculations, the mean values for the mobile molecules 
will be skewed. 

Therefore, depending on your intended output this function could be approached 
in multiple ways. 

```{r}

# calculate mean RPM and mean Counts for heterograft samples
selected_samples <- c("heterograft_1", "heterograft_2", "heterograft_3")
means <- RNAmean(data = sRNA_DESeq2, conditions = selected_samples)


```
 <br>

# Session information
```{r}
sessionInfo()
```