---
title: "mobileRNA: Explore candidate mobile sRNAs & sRNAs population-scale changes"
author: Katie Jeynes-Cupper, Marco Catoni
date: "`r Sys.Date()`"
output:
  BiocStyle::pdf_document
toc_depth: 3
number_sections: true
theme: united
highlight: tango
fig_width: 7
vignette: >
 %\VignetteIndexEntry{mobileRNA}
 %\VignetteEngine{knitr::rmarkdown}}
 %\VignetteEncoding{UTF-8}
 %\VignettePackage{mobileRNA}
 %\VignetteDepends{dplyr}
 %\usepackage[utf8]{inputenc}
---
<br>
```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  fig.align='center',
  external=TRUE,
  echo=TRUE,
  warning=FALSE,
  comment = "#>"
)

library(dplyr)
```

 
# Introduction
In plants, systemic signalling is an elaborated molecular system which
coordinates plant development, integrating and transmitting the information 
perceived from environment to distant organs. An important role in 
long-distance signalling is played by small RNA molecules (sRNAs). These 
endogenous sRNAs can be produced in a tissue and then transported
systemically across the vascular system into recipient organs, where they can
induce a molecular response and coordinate physiological changes. Plant grafting
can be utilised to create chimeric plant systems composed of two genotypes. For 
example, grafting can join tomato and eggplant or different grapevine varieties. Grafting of horticultural crops can lead to favorable traits, such 
as improved plant vigour or architecture, and resistance to stress. sRNAs have
been known to move across a graft junction, hence, understanding the complex
regulatory networks controlled by sRNAs traveling from different genomes could
assist the development of novel methods for transferring traits into crops, as
alternatives to traditional breeding or transgenic approaches.

To identify sRNA population which are mobile or native, analysts currently adopt 
and adapt a general RNA sequencing pipeline. Several genomic studies have used 
grafting to explore and characterise mobile sRNAs in chimeric systems, however, 
it is clear that there is not a  standardised approach.

Here we introduce the R package, `mobileRNA`, a recommend pipeline and analysis 
workflow for the identification of mobile sRNAs and changes in static/native 
sRNA populations in chimeric systems. This workflow can also support standard 
sRNAseq analysis between treatment and control conditions. For example, to
identify sRNA population changes due to the application of a treatment such as 
cold/heat stress or exposure to a pest. 

The pipeline recommends an alternative alignment method which yields an improved
identification of the genomic origins of sRNA molecules. Along with the tools 
within this R package to assist analysis including the characterization of 
different population, visualization of the results, and supports output for 
functional analysis. 
<br>

# Methods

This manual offers a pipeline for the analysis of sRNAseq data and can assist 
the identification of mobile endogenous sRNAs in chimeric systems, plus, 
identify population level changes such as sRNAs which have been gained or lost 
due to a treatment in comparison to the control. This second part is applicable
to both chimeric and non-chimeric (treatment vs. control) systems. 

There are two clear area which must be optimised to make better predicts of the  
sRNA mobility and population dynamics including the alignment steps and the
analysis steps. 

We can make the best use of the existing alignment algorithm by providing them 
with as much information as possible. This will help the algorithm make the most 
informed decisions and better place the sRNA within the genome(s). Here, we 
propose a method inspired by the RNAseq analysis of hybrid species; aligning samples to a merging genome. A merged genome is a single 
FASTA file containing multiple genome assemblies. For a system which may contain
sRNAs from different genotypes, this allows the algorithm to 
unambiguously predict the genome of origin for the sRNAs. However, to be able to understand which genome the molecules originate from each genome needs to be 
distinguishable within the merged genome. `mobileRNA` offers a function 
to do just that. It merges two genome assemblies into a single file and is 
able to maintain the distinguishability by adding a distinct pre-fix to 
chromosome names in each genome. The merged genome is one part of the effort, 
the other information we can supply to the aligner is a list of de novo sRNA 
loci identified across sample replicates. This ensures consistency across the 
analysis by preventing false assumptions. Consider that sRNA molecules are 
expected to have a very low abundance; It might be the case that in one 
replicate the read abundance of a given sRNA locus was not significant enough to 
record as a sRNA cluster, while in another replicate it was recorded. So, 
it would be wrong to assume there are zero reads at the locus. Collectively, 
considering the extra information should optimise the alignment of sRNAs to the 
best locations within the merged genome.  

<img align="right" width="300" src="../man/figures/program_flow.png">

The summarised workflow is shown here, where it starts in `R` to merge 
the two genome assemblies into one, then the pre-processing moves into Linux to 
align each replicate to the merged reference and then back into `R` to 
undertake the analysis. 
<br><br>

The analysis workflow using `mobileRNA` can be completed in a simple 4-step 
process to identify potentially mobile sRNAs and/or to explore 
the population dynamics. Across the analysis, additional features are available 
to advance the analysis. This includes:

* Principal component analysis
* Heatmaps 
* Distribution plots
* Statistical analysis with `edgeR` or `DESeq2` methods
* Steps to assist functional analysis. 

When working with a chimeric system, the core steps offer the ability to remove 
mapping errors by comparing controls to the treatment. It identifies sRNA 
clusters from the foreign genome and remove those which have read counts in 
the control samples - as it is unexpected to observe these. However, if the 
chimeric system is expected to share some or a high level of similarity it might 
be insightful to the analysis to not remove these sRNA clusters. 

After importing the data into R using [mobileRNA::RNAimport()], the second core 
step is the consensus dicer classification (see function 
[mobileRNA::RNAdicercall()]). For a given sRNA cluster, within each sample a 
sRNA classification is predicted. This information is used to define the 
classification of the cluster based on the consensus across replicates. 
There is a range of parameters to control how these are drawn, making it either 
stringent or loose, which will alter the downstream analysis. 

For the third core step involves the use of differential analysis. It should be 
emphasized that this is an optional step for the identification of mobile sRNA, 
while, for the exploration of population dynamics it is a mandatory step. 
Here we include a single function which can be instructed to undertake 
differential analysis using either the `edgeR` or `DESeq2` method (see function 
[mobileRNA::RNAdifferentialAnalysis()]). The function outputs additional columns 
to your working dataset, including the raw count mean, log2FoldChange, p-value 
and adjusted p-value. 

Here we describe the final core step for each workflow. 
For the identify the candidate mobile molecules, we introduce the
[mobileRNA::RNAmobile()] function. It contains parameter which can 
either result in stringent or looser outcomes by utilises the number of 
replicates which contributed to the consensus dicer classification as 
a threshold value. For instance, it would be more stringent to select sRNA 
clusters which were unambiguously classified across condition replicates. 
On the other hand, the final step to identify population changes is to locate 
molecules gained or lost. 


<br><br><br>
```{r, fig.align="centre", echo=FALSE,out.width="750", out.height="750",fig.cap="The analysis pipeline for mobileRNA" }

knitr::include_graphics("../man/figures/complete_workflow_mobile_native3.png")
```
<br>
<br>
The analysis pipeline,  splits into two tracks when trying to identify candidate
mobile sRNAs and population dynamics. This can be seen in the diagram above. 

# Installation

The latest version of `mobileRNA` can be installed via Bioconductor:

```{r,  eval=FALSE, message=FALSE}
if (!require("BiocManager", quietly = TRUE))
    install.packages("BiocManager")

BiocManager::install("mobileRNA")
```


```{r,message=FALSE}
library(mobileRNA)

```

## Example data set

For the following examples, a simulated sRNAseq data set was generated to 
simulate the movement of sRNA molecules in a compatible plant graft system. This
involves Tomato (*Solanium lycopersicum*) as a rootstock to an Eggplant 
(*Solanium melongena*) scion. There are three heterograft replicate, 
where each is an individual tomato replicate spiked with the same random set of 
150 tomato sRNA clusters. These are known as:

* `heterograft_1`
* `heterograft_2`
* `heterograft_3`  

There are three self-graft replicates, where each is an individual tomato 
replicate without the spiked tomato sRNA clusters. These are:

* `selfgraft_1`
* `selfgraft_2` 
* `selfgraft_3`

The replicates mirror each other where, for instance, `heterograft_1` 
and `selfgraft_1` are the same replicate, either with or without the spiked 
clusters. 

The data set, called `sRNA_data`, stores a matrix containing the
pre-processed data. These can be loaded in the R environment by using the 
following command:

```{r Load, message=FALSE}

data("sRNA_data")

```


## Data organisation
It is recommended to rename your files to names you wish for them to
be represented as within the analysis and shown as labels in plots. It is easier
to do this before processing +  it makes the analysis easier!

For example, instead of names such as:

- 1: `sample_1.fq`
- 2: `sample_2.fq`
- 3: `sample_3.fq`
- 4: `sample_4.fq`
- 5: `sample_5.fq`
- 6: `sample_6.fq`

For the example data set included in the package, here we have renamed the
files based on the condition (treatment or control).For the hetero-grafts, where 
the is a eggplant scion and an tomato rootstock:

- 1: `heterograft_1.fq`
- 2: `heterograft_2.fq`
- 3: `heterograft_3.fq`

and for the eggplant self-grafts:

- 4: `selfgraft_1.fq`
- 5: `selfgraft_2.fq`
- 6: `selfgraft_3.fq`
<br>


# Pre-Processing
sRNAseq pre-processing involve trimming, alignment and clustering. Going 
forward, the pipeline assumes that the sRNA-seq samples have met quality control 
standards. These steps are part of the recommended pipeline, and involve the use
of  `ShortStack` (https://github.com/MikeAxtell/ShortStack) in Linux. The
follow examples are not reproducible, and require alterations to fit your data
and directory structure. 
<br>

## Pre-mapping

Here we generate a merged reference genome (FASTA) and a merged annotation 
(GFF). The functions to support this alter chromosome names in each genome
to support downstream analysis by ensuring the two genomes are distinguishable.  
They remove punctuation and add a prefix to each chromosome name, unique to each
assembly. By default, the pre-fix included the user-defined string, plus,
an underscore seperating the prefix and the pre-existing chromosome name. 
`A` is added to the genome supplied to `genomeA`/`annotationA` and `B` is added 
to the genome supplied to `genomeB`/`annotationB`. These can be customized to 
the users preference.

*It is important that the same alterations are made to each genome in the merged
files for downstream analysis - otherwise the annotation file will not align 
with the chromosome names used for alignment.*
<br>

### Merging Genome Assemblies

Here we merge the two reference genomes into a merged genome using the
`RNAmergeGenomes()` function. 

```{r, eval = FALSE}

RNAmergeGenomes(genomeA ="/Users/user1/workplace/reference/ref1.fa",
               genomeB ="/Users/user1/workplace/reference/ref2.fa",
               out_dir = "/Users/user1/workplace/reference/ref_merged.fa")

```
<br>


## Merging genome annotations

Now, repeat for the genome annotations (GFF) - this is required for downstream 
analysis, for example to identify genomic features which overlap the sRNA 
producing loci. This can be undertaken using the `RNAmergeAnnotations()`
function.

```{r, eval = FALSE}

## merge the annotation files into a single annotation file
RNAmergeAnnotation(annotationA = "/Users/user1/workplace/
                                  annotation/annotation_1.gff3",
                   annotationB = "/Users/user1/workplace/
                                  annotation/annotation_1.gff3",
                   out_dir = "/Users/user1/workplace/
                            annotation/merge/anno_merged.gff")

```



## Auto-detection of sRNA cluster
Here we identify and build a list sRNA clusters within each sample to assist
the mapping step to ensure consistency across the analysis. This step
is very important to consider as it prevents false assumptions. This step aligns 
a replicate to the given genome assembly and the outputs contains loci where 
sRNA clusters were found. 

### Step 1 - Cluster analysis with `ShortStack`

``` bash
ShortStack \
--readfile <control_1.fastq> \
--genomefile <merged_reference.fa> \
--bowtie_cores 6 \
--mmap n \
--mismatches 0 \
--nohp \
--outdir <./output/directory>

```


### Step 2 - Build sRNA cluster list 

Now, we collate all the sRNA loci information from each sample into a text file. 

``` r
# location of step 1 output
folder <- <./output/directory/from/step/1/>

# name and location to save output file to (must be .txt)
save_folder <- <./output/directory/ClustersInfo.txt>

# names of samples (ie. folder names)
sample_names <- c("<treatment_1>", "<treatment_2>", "<control_1>","<control_2>")


loci_info <- RNAloci(files = folder, 
             out = save_folder,
             samples = sample_names)
```



## Mapping   

Each sample is mapped to the merged reference genome with the list of sRNA 
clusters. 


``` bash
ShortStack \
--readfile <control_1.fastq> \
--genomefile <merged_reference.fa> \
--locifile <./output/directory/ClustersInfo.gff3> \
--bowtie_cores 6 \
--mmap n \
--mismatches 0 \
--nohp \
--mincov 5 \
--outdir <./output/directory/step2/>

```
<br>


# Analysis
Here, we will analyses the output of the pre-processed data to identify 
candidate mobile sRNA molecules and identify changes in the native sRNA 
population, exploring those which have been gained and lost due to the 
treatment in comparison to the control - and those statistically more/less
abundant. 
<br>

## Import data
The sRNAseq pre-processing steps generate a folder for each sample storing the 
results. We are interested in the file `Results.txt`. Here, the `RNAimport()` 
function imports the `Results.txt` file for each sample, extracting specific 
pieces of information and storing it all in a single working dataframe. To do 
so, the function requires the directory path which stores the output folders 
produced by `ShortStack`. Along with a vector containing the names of each sample
to include in the import - this must correspond to the folder names previously 
mentioned to which the directory path leads to. 

```{r, eval = FALSE, message=FALSE}

## Import & organise data.
results_dir <-  "./analysis/alignment_unique_two/"

sample_names <- c("heterograft_1","heterograft_2", "heterograft_3",
                  "selfgraft_1", "selfgraft_2", "selfgraft_3")


sRNA_data <- RNAimport(input = "sRNA",
                       directory = results_dir,
                       samples = sample_names)

```


## Sample-level quality control
A handy step in the analysis is to assess the overall similarity between
sample replicates to understand which samples are similar and/or different. 
As well as understand where the largest variation is introduced and 
whether the data meets your expectations and if there are outliers. It is 
expected that between the conditions, the sample replicates show enough 
variation to suggest that the replicates are from different groups. Here we 
undertake sample-level quality control using three different methods:

- Distribution of sRNA classes within each sample
- Principle component analysis (PCA)
- Sample distance heatmap using hierarchical clustering

The PCA and heatmap both use an unsupervised clustering methods which involves 
an unbiased log2-transformation of the raw counts. This will emphasis the 
clustering to improve visualization. 
<br>

### Plot the distribution of RNA classes within each sample
Here, `RNAdistribution()` function can generate a number of different customized 
plots to represent the number of each sRNA class identified within a sample. It
outputs a table and the plots. 

The results can be plotted as either a bar chart (`style = "bar"`)  or a 
line graph (`style = "line"`) for each sample and can be shown in a facet
(`facet = TRUE`) or in as a single line graph, where each line represents a
sample (`together=TRUE`). Alternatively, the results can be plotted individually
for each sample in either format (`together = FALSE`).


```{r, echo=FALSE}
cap9 <- "An example facet line graph to show the distribution of RNA classes within each sample."

cap10 <- "An example facet bar graph to show the distribution of RNA classes within each sample."

cap11 <- "An example line graph showing all the replicates plotted on a single plot."


```

```{r, message=FALSE}

# plot each replicate as a line, separately, and facet 
sample_distribution_line <- RNAdistribution(sRNA_data,
                                            style = "line",
                                            together = FALSE, 
                                            facet = TRUE,
                                            colour = "darkgreen")

                                            
 # plot each replicate as a bar, separately, and facet 
sample_distribution_bar <- RNAdistribution(sRNA_data,
                                           style = "bar",
                                           facet = TRUE,
                                           colour ="lightblue")

# plot each replicate on a single plot
sample_distribution <- RNAdistribution(sRNA_data,
                                           style = "line",
                                           together = TRUE)

```

Lets view these plots:

```{r, message=FALSE, fig.cap=cap9, fig.show="hold"}
# View plot (only)
sample_distribution_line$plot

```
<br>
```{r, message=FALSE, fig.cap=cap10, fig.show="hold"}
# View plot (only)
sample_distribution_bar$plot

```
<br>
```{r, message=FALSE, fig.cap=cap11, fig.show="hold"}
# View plot
sample_distribution$plot

```



### PCA
Principal Component Analysis (PCA) is a useful technique to illustrate sample
distance as it emphasizes the variation through the reduction of dimensions in
the data set. Here, we introduce the function `plotSamplePCA()`

```{r, echo=FALSE}
cap3 <-"An example of a PCA, illustracting the sRNA data set sample similarity"

```

```{r, message=FALSE, fig.cap=cap3, fig.show="hold", }

group <- c("Heterograft", "Heterograft", "Heterograft",
            "Selfgraft", "Selfgraft", "Selfgraft")

plotSamplePCA(sRNA_data, group)

```

This PCA is somewhat not what we would expect to see in a real data set. This is
because PC1 is showing the variation between the non-spiked and spiked version 
of the replicate while PC2 shows the natural variation between the replicates. 

It is more likely that in a real sRNA data set, you might expect more or 
less variation between the conditions. For example, analysis of a self-graft 
vs heterograft may show little variation between the conditions. This might be 
expected because there may only be a very small number of endogenous 
mobile/foreign sRNAs that are present in the whole population while the
population of sRNAs present in the destination tissue is expected to be 
largely similar. 
<br>

### Hierarchical clustered heatmap 

Similarly, to a PCA plot, the `plotSampleDistance()` function undertakes
hierarchical clustering with an unbiased log transformation to calculate sample
distance and is plotted in the form of a heatmap.

```{r, echo=FALSE}
cap4 <-"An example of a heatmap,illustrating the sRNA data set sample similarity"

```

```{r ,message=FALSE, fig.cap=cap4, fig.show="hold"}

plotSampleDistance(sRNA_data)

```
<br>


## Define the dicer-derived sRNA consensus classification
Have a look at the `sRNA_data` object, you will see that for each sample the
sRNA class for a given cluster has been determined (see columns with names 
containing with "DicerCall_") which will state a number from 20-24 in the data 
which represents the nucleotide length of the sRNA, or, state NA/N which 
represents that the sRNA was unclassified in the sample. 

The `RNAdicercall()` function is used to calculate the consensus dicer 
classification for each sRNA cluster based of the classification by each
sample replicate. Ties for the classification can be handled in two ways, either
select one of the tied classes at random or choose to exclude. The exclude 
option is set as the default, however, it is worth noting that when there is a 
tie between the choice of a class or unclassified result this option will always
select the class choice over the unclassified result. 

When working with samples from a chimeric system, the function contains a 
specialised parameter which should be utilized. This is `chimeric=TRUE`, along
with the `genome.ID` and `controls` parameters. Where `A_` represents the prefix
added to the tomato genome. This helps optimise classification by removal of 
potential mapping errors. 

The used can alter the functions decision making by telling it to base the 
consensus on specific samples or across all samples in the analysis (default).
Plus, if the user utilises the `tidy=TRUE` parameter, this will remove sRNA
cluster which have an unclassified (N) consensus dicer classification - reducing
noise in the data. 


```{r, message=FALSE}

# define consensus, store as a data summary file.
sRNA_data_consensus <- RNAdicercall(data = sRNA_data, 
                                     chimeric = TRUE, 
                                     genome.ID = "A_", 
                                     controls = c("selfgraft_1", 
                                                  "selfgraft_2", 
                                                  "selfgraft_3"))



```

For the downstream analysis, it can be useful to define the distinct groups of 
sRNA classes depending on your organism. For plants, it is beneficial to select
a group of 24-nt and another containing 21/22-nt sRNAs.  
To subset the data, use the `RNAsubset()` function to choose which sRNA 
populations to include: 20-nt, 21-nt, 22-nt, 23-nt, or 24-nt in this data. 


For example, here we select from the population of sRNA the 24nt and also a 
21/22nt population. In this vignette, we do not continue to use these group,
however, it might be preferable to do so in your analysis - at any point. 

```{r, message=FALSE}

# Subset data for analysis: 24-nt sRNAs
sRNA_24 <- RNAsubset(sRNA_data_consensus, class = 24)
# Subset data for analysis: 24 21/22-nt sRNAs
sRNA_2122 <- RNAsubset(sRNA_data_consensus, class = c(21, 22))

```
<br>


### Plot the dicer-derived sRNA consensus classification

Similar to before, the `RNAdistriution()` function can be used to visualize the 
distribution of the consensus sRNA classes.  

The function can plot the absolute or relative frequency, use argument 
`relative`. It can be beneficial to view the absolute frequency as well as the 
relative to observe whether the data meets your expectations.

```{r}

consensus_plot <- RNAdistribution(data = sRNA_data_consensus,
                                  style = "consensus")
```

```{r, echo=FALSE}
cap22 <-"An example of the distribution of small RNA consensus dicer classifications. "

```
Now, view the plot:
```{r, fig.cap= cap22}

# view 
consensus_plot$plot
```
<br>


## Differential expression analysis with `DESeq2` or `edgeR`
Differential expression (DE) analysis is undertaken to identify sRNA which 
are statistically significant to discover quantitative changes in the abundance
levels between the treatment (hetero-grafting) and the control (self-grafting)
groups. This technique can be undertaken with a variety of tools, in `mobileRNA`
users have the option to use the `DESeq2` or `edgeR` analytical method.

Based on your data, one analytical method might be preferable over another. 
For instance, the applied `DESeq2` method is not appropriate when the experiment 
does not contain replicate (ie. one sample replicate per condition). While,
`edgeR` can be used. Here, we have included the recommended practice for `edgeR` 
when the data does not contain replicates. This option can be employed by 
setting a custom dispersion value, see argument `dispersionValue`.

Please note that this step is optional and not a required part of the analysis
for candidate mobile sRNA identification but is required for population changes
difference for both chimeric or nonchimeric systems. 

```{r DEprep, message = FALSE, warning = FALSE}

# sample conditions in order within dataframe
groups <- c("Heterograft", "Heterograft", "Heterograft",
            "Selfgraft", "Selfgraft", "Selfgraft")

## Differential analysis of whole dataset: DESeq22 method 
sRNA_DESeq2 <- RNAdifferentialAnalysis(data = sRNA_data_consensus,
                              group = groups,
                              method = "DESeq2")

```
<br>

# Identify candiate mobile sRNAs in chimeric systems
We identify candidate mobile sRNAs by identifying clusters which are mapped 
to the foreign genome and extracting the most abundant sRNA sequence and 
classification. These can be isolated using the `RNAmobile()` function. 

In respect to the example data set, we are looking to identify sRNAs traveling 
from the tomato rootstock to the eggplant scion in the heterografts. Hence, this
function will look to select clusters mapped to the tomato genome and remove 
those mapped to the eggplant genome. Previously, the example of the prefix `A_` 
was added to the chromosomes of the tomato genome while prefix `B_` added to 
the eggplant genome. To remove or keep specific clusters, we align this request
with the `"task"` parameter.

Note that the `RNAmobile()` function can take into account the statistical
significance. If set to consider this, the function will filter sRNA based on 
an adjusted p-value threshold = 0.05. The threshold can be changed to make it 
less stringent by using the argument `padj`.Similarly, if you would prefer to 
extract the mobile sRNA based on the p-value, rather than the adjusted p-values,
a numeric threshold can be set for the argument `p.value`. As default, the 
function does not consider the statistical values and properties of the sRNAs. 
To consider, use `statistical=TRUE`


```{r , message=FALSE}

# vector of control names
control_names <- c("selfgraft_1", "selfgraft_2", "selfgraft_3")


## Identify potential tomato mobile molecules
mobile_sRNA <- RNAmobile(data = sRNA_DESeq2, 
                         controls = control_names,
                         genome.ID = "A_",
                         task = "keep", 
                         statistical = FALSE)

## Identify statistically significant potential tomato mobile molecules 
mobile_sRNA_significant <- RNAmobile(data = sRNA_DESeq2, 
                         controls = control_names,
                         genome.ID = "A_",
                         task = "keep", 
                         statistical = TRUE) # change this parameter


```
<br>


### Heatmap plots to represent mobile molecules
We can plot our results as a heatmap, which represents the normalised
reads-per-million (RPM) values which have been log transformed.  
<br>

Here we will plot all potential mobile molecules and those which are 
statistically significant:

```{r, echo=FALSE}
cap7 <- "An example heatmap of candidate mobile small RNAs.Where the columns represent the sample replicates and the rows represent the small RNA cluster."

cap8 <- "An example heatmap of candidate mobile small RNAs, which are statistically signifcant (adjusted pvalue < 0.05). Where the columns represent the sample replicates and the rows represent the small RNA cluster."



```

```{r,fig.cap=cap7, fig.show="hold" }

p10 <- plotHeatmap(mobile_sRNA, row.names = FALSE)

```
<br>

```{r,fig.cap=cap8, fig.show="hold"}
p11 <- plotHeatmap(mobile_sRNA_significant, row.names = FALSE)

```

### Save output 
```{r, eval = FALSE}

write.table(mobile_sRNA, "./candidate_mobile_sRNAs.txt")

```

<br>

## Functional analysis 
At this point in the analysis, the working dataframe contains candidate mobile 
sRNAs. Now, we can extrapolate information to assist the prediction of their 
targets and role in the biological system. 

We offer three different tools to assist the functional analysis. The first, 
can be used to identify genomic features associated with the sRNA producing 
loci associated to each cluster. This function is known as `RNAattributes()`. 
The second tool does something very similar, it identifies the same overlaps 
but returns a value stating either the absolute or relative number of sRNA 
clusters which over overlap with specific genomic features. This function 
is known as `RNAfeatures()`. Finally, the last tool, called `RNAsequences()` 
calculates the consensus sRNA sequence for each candidate and calculates the
potential target DNA sequence. 


IMPORTANT: Alterations to the genome assemblies by the RNAmergeGenomes()
function must be replicated in the annotations. A merged annotation with the 
same amendments can be created with the function RNAmergeAnnotations(). 
<br>

### Add genomic attributes to sRNA clusters   
Each sRNA cluster contains coordinates, these can be matches with coordinates in
an annotation file. A match occurs when the cluster is found within the 
coordinates of a feature. If there is a match, the function returns the input 
dataframe with additional fields of information from the annotation file. 

This will enable us to identify the genomic features generating the mobile 
sRNAs. Here we will only be overlapping the data with genes, 
and adding a buffer region of 1 kb upstream and downstream of the each gene. 

```{r, eval = FALSE}

mobile_df_attributes <- RNAattributes(data = mobile_sRNA, match ="genes",
                            annotation = "./annotation/merged_annotation.gff3")

```
<br>

### Summarise sRNA cluster overlaps with genomic features 
Very similar to before, we can find overlaps between our candidate sRNA clusters 
and genomic features. However, this time we can calculate the relative
or absolute number of sRNA clusters which are associated to each type of
feature. These include promoter regions, exon, introns, untranslated regions 
and repeat regions.The results can either be displayed in the matrix as an
absolute value or as a percentage of the total:

NOTE: This function look for the exact matches in the locus (chromosome, 
start and end regions) between the sRNA cluster and the annotation file.  

```{r, eval = FALSE}

mobile_df_features <- RNAfeatures(data = mobile_sRNA,
                            annotation = "./annotation/merged_annotation.gff3", 
                      repeats = "./annotation/merged_annotation.gff3")

```
<br>

### Retrieve RNA sequence from mobile sRNA clusters
To predict the the targets of the mobile sRNA candidates, we need to extract
the RNA sequence. The `RNAsequences()` function can be used to extrapolate the 
consensus RNA sequence and also calculate the complementary sequences. It does 
so by identifying whether the most abundant sRNA is consistent across
replicates, and if so, it extracts the RNA sequence and calculates the RNA & DNA 
complementary sequences, as well as stating the length of the sequence. However, 
if there is a tie between the most abundant sequences within a cluster the user
can utilise the `duplicates` parameter to choose whether to set the consensus
sequence as NA or to pick one at random. Similarly, to make the analysis more 
stringent there is a threshold parameter which can be used to set the minimum 
number of replicates required to share the sRNA sequence to count as a match. 

```{r}

mobile_sequences <- RNAsequences(mobile_sRNA)


```
<br>

Target prediction tools such as `psRNATarget` (Xinbin Dai, Zhaohong Zhuang and 
Patrick X. Zhao (2018). psRNATarget: a plant small RNA target analysis server 
(2017 release). Nucleic Acids Research. doi: 10.1093/nar/gky316) can be used. 

For a tool like `psRNATarget`, we can manipulate the output of `RNAsequences()` 
to match the input style for target prediction using the following code:
```{r, eval = FALSE, message=FALSE}

library(dplyr)
# select the cluster and sequence columns 
sequences <-mobile_sequences %>% select(Cluster, Sequence)

# add prefix, remove row with NA
prefix <- ">"
sequences$Cluster <- paste0(prefix, sequences$Cluster)
sequences <- na.omit(sequences)

# convert
res <- do.call(rbind, lapply(seq(nrow(sequences)), function(i) t(sequences[i, ])))

# save output 
write.table(res, file ="./candidate_mobile_sRNAs_sequences.txt" ,
            row.names = FALSE, col.names = FALSE, quote = FALSE)

```
<br>

Other steps can be take at this step including alignment of the mobile sRNA 
sequences to identify consensus sequences. For example this can be undertaken 
with the R package `bioseq`. 

```{r}

library(bioseq)

mobileRNA_seq <- bioseq::rna(mobile_sequences$Sequence)

bioseq::seq_consensus(mobileRNA_seq)


```



# Explore sRNA population difference between treatment & control
Here, we will look at comparing the native population of sRNAs and how they 
might have changes in the tissue due to the treatment compared to the 
control. 

As a reminder, the data used here will not yield any results as the 
treatment and control samples contain the exact same population of eggplant 
sRNAs, the only difference in the treatment samples are the spiked tomato 
sRNA clusters. 

We have already undertaken the statistical analysis in the previous steps, we
will be utilising this dataset going forward.

### Differences in sRNA abundance 
When comparing treatment to control conditions, it might be the case that 
the same sRNA clusters are found within both, yet, there could be difference in 
the total abundance of the shared clusters. For instance, for a given sRNA 
cluster the samples in the treatment condition might have a greater abundance 
than the samples in the control condition. 

The statistical analysis calculated the log2FC values for each sRNA cluster by 
comparing the normalised counts between treatment and control. Here, 
a positive log2FC indicates an increased abundance of transcripts for a given 
sRNA cluster in the treatment compared to the control, while negative log2FC 
indicates decreased abundance of transcripts for a given sRNA cluster. The 
statistical significance of the log2FC is determined by the adjusted pvalue.

Here we will filter the data to select sRNA clusters which are statistically 
significant, and then plot the results as a heatmap to compare the conditions. 
```{r, fig.show="hold"}
# select only significant sRNAs
significant_sRNAs <- RNAsignificant(sRNA_DESeq2)
```

Plot the results:
<br>
```{r, fig.show="hold"}
#plot the RPM as heatmap 
p1 <- plotHeatmap(significant_sRNAs, row.names = FALSE)

# plot the log2fold change 
```


## Identify gain & loss of sRNA populations
The `RNApopulation()` function can be utilised to identify unique 
sRNA populations found in the treatment or control conditions. Basically, sRNA
which are gained in the treatment or lost due to the treatment. 

First lets look at the sRNA clusters gained to the treatment condition.
In the chimeric heterografts, we expect that the foreign sRNAs will also be 
selected in this pick-up, therefore, we can use the parameter `genome.ID` to 
remove sRNA cluster related to the foreign genome. 

Here we have used the data set generated from the differential analysis, 
however, you may want to only look at sRNA clusters which are statistically 
significant - generated in the previous section. 


```{r}

# select sRNA clusters only found in treatment & not in the control samples
gained_sRNA <- RNApopulation(data = sRNA_DESeq2, 
                                  conditions = c("heterograft_1", 
                                                 "heterograft_2" , 
                                                 "heterograft_3"),
                                  chimeric = TRUE, 
                                  genome.ID = "A_", 
                                  controls = c("selfgraft_1",
                                               "selfgraft_2", 
                                               "selfgraft_3"))

# look at number of sRNA cluster only found in treatment 
nrow(gained_sRNA)

```


Now, the sRNA clusters lost and only produced in the control condition:
```{r, eval=FALSE}

# select sRNA clusters only found in control & not in the treatment samples
lost_sRNA <- RNApopulation(data = sRNA_DESeq2, 
                                conditions = c("selfgraft_1", 
                                               "selfgraft_2" , 
                                               "selfgraft_3"))
# look at number of sRNA cluster only found in control  
nrow(lost_sRNA)

```
<br>

The data here can be manipulated in many ways, you may wish to extract
statistically significant sRNA clusters within a population to explore 
further. For this you can utilise the `RNAsignificant()` function. 

The plotting functions within the package can be used to display these results, 
specifically `RNAdistribution()` and `plotHeatmap()`. Similarly if you 
are comparing several different treatments, a venn diagram could be plotted to 
observe whether any gained or lost populations of sRNA are shared. 

## Functional analysis of gained & lost sRNA populations 
Now we have identified unique populations produced or not produced in our 
treatment samples compared to our control samples, we can extract the RNA 
sequences to undertaken target prediction and then onward to gene ontology 
enrichment analysis. 

```{r, eval = FALSE}

gained_sRNA_sequences <- RNAsequences(gained_sRNA)
lost_sRNA_sequences <- RNAsequences(lost_sRNA)

```

Moreover, we can identify genomic features associated with these sRNA clusters 
which are:

* 1 - unique to the treatment and absent in the control ie. gained
* 2 - unique to the controls but absent in the treatment ie. lost

```{r, eval = FALSE}

gained_sRNA_attributes <- RNAattributes(data = gained_sRNA, match ="genes",
                            annotation = "./annotation/merged_annotation.gff3")


lost_sRNA_attributes <- RNAattributes(data = lost_sRNA, match ="genes",
                            annotation = "./annotation/merged_annotation.gff3")
```
<br>

# Additional features

The *mobileRNA* package offers several optional functions to aid analysis. 
This includes a function to calculate the mean RPM and counts across
specific samples and also calculate the overlap between genomic features and
sRNA clusters.

<br>

## Calculate RPM and Count means for specific samples
This function calculates the RPM mean and Count mean across specific samples.The 
output of the calculation is added as an additional column to the input 
dataframe. 

This can be manipulated to be used before or after identified mobile RNAs. When 
calculating means after identifying mobile molecules, it is recommend to base 
this on the heterograft samples rather than the full dataset 
(self-grafts + heterograft replicates) as all potential mobile sRNAs should have 
zero counts or RPM value in the self-grafts control replicates. By including the 
full dataset in these calculations, the mean values for the mobile molecules 
will be skewed. 

Therefore, depending on your intended output this function could be approached 
in multiple ways. 

```{r}

# calculate mean RPM and mean Counts for heterograft samples
selected_samples <- c("heterograft_1", "heterograft_2", "heterograft_3")
means <- RNAmean(data = sRNA_DESeq2, conditions = selected_samples)


```
 <br>

# Session information
```{r}
sessionInfo()
```