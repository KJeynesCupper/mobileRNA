---
title: "RNAlocate: Quick Start"
author: Katie Jeynes-Cupper, Marco Catoni
date: "`r Sys.Date()`"
output: 
  html_document:
    toc: true
    toc_depth: 3
    number_sections: true
    theme: united
    highlight: tango
fig_width: 7
vignette: >
  %\VignetteIndexEntry{RNAlocate-Quick-Start}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
   %\usepackage[utf8]{inputenc}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
knitr::opts_chunk$set(collapse = TRUE, comment = "#>", fig.width = 7, fig.height = 7, fig.align = "center")
library(RNAlocate)
```

# Introduction 
Small RNA (sRNA) molecules are renown for their mobility and their capacity to 
introduce epigenetic changes to alter the expression of genes. There are two 
primary methods to observe the movement of sRNA molecules. One method uses 
RT-PCR to show the presence of a specific molecule within a tissue, while the 
other increasingly popular method, known as sRNA sequencing, can show a
population of sRNA molecules. Plant grafting is a historical horticultural 
method to introduce favorable agronomic traits, including resistance to 
pathogens and improved plant vigour. It is widely believed that some 
grafting-induced traits are credited to changes in the epigenome which were 
induced by mobile signals traveling between the two grafting partners, known as 
the scion (top part) and rootstock (bottom part, including roots). An increasing 
body of evidence suggests that sRNA molecules commute the information 
across the graft junction. 
The *RNAlocate*  package represents a complete guide for the pre-processing and 
analysis of sRNA-seq (sRNA-seq) data taken from plant grafting experiments. 
*RNAlocate* provides a guided pre-process pipeline includes cleaning and mapping, 
before analysing the data to identify potentially mobile sRNA molecules at 
lengths between 20-24 nucleotides from one genotype found within the tissue of 
another genotype. The package also enables users to identify the potential 
biological function and target sequences of the mobile sRNAs. 

The tool offers a platform for users to easily work on sRNA-seq data within R 
studio and Linux and does not require the user to have extensive knowledge of 
coding or bioinformatics. Currently, there is no tool available which 
allows for this type of analysis. 

# Method


# Installation
## Download and load the package from GitHub:

```{r , eval = FALSE}
devtools::install_github(RNAlocate)
```

# Load the package into R session

```{r Load, message=FALSE}

library(RNAlocate)
library(DESeq2)
library(edgeR)

```


## Dependancies 
The recommended pre-processing steps require the installation of several 
programs to the command line, which include:
- FastQC (https://www.bioinformatics.babraham.ac.uk/projects/fastqc/)
- Trimmomatic (http://www.usadellab.org/cms/?page=trimmomatic)
- Shortstack (https://github.com/MikeAxtell/ShortStack)
- BEDtools (https://bedtools.readthedocs.io/)

# Set up workplace
Use the `create_workplace` function to set up the working directory
structure and place the following items in each:

- *raw* : Raw samples (.fq/.fastq) (Name replicates appropriately)
- *reference* : Two reference genomes (.fa/.fasta)
- *annotation* : Two annotation genomes (.gff/.gff3) 

```{r, eval = FALSE}
# set up working dorectory using the *dir_relocate* function
create_workplace("/Users/user1/projectname/workplace/")
```

# Pre-processing
The pre-processing steps are very similar to other pre-processing steps for 
different sequencing data. The only difference in this pipeline lies within the 
mapping steps, where samples are mapped to a merged reference genome. 
The mapping step first aims to locate the sRNA in each sample, 
then each replicate is mapped to all identified sRNA loci across the samples
within the analysis. This ensures that each sample has an accurate count for 
each sRNA molecule. The mapping and cluster analysis is undertaken using 
ShortStack. 

## 1. Merge the two reference genomes into a single merged reference genome
```{r, eval = FALSE}
## merge genome references into a single genome
mergeFiles(files = "/Users/user1/projectname/workplace/reference/",
            out = "/Users/user1/projectname/workplace/reference/merge/")
```

## 2. Check the quality of raw sample files. 

```{r, eval = FALSE}
checkQuality(files = "/Users/user1/projectname/workplace/raw/")
```

## 3. Trim raw sample files.  
This is to remove adapter sequences (AGATCGGAAGAGCACACGTCT), 
low quality reads and remove reads outside the desired nucleotide length (16-30).

```{bash , eval = FALSE}

mkdir -p  /Users/user1/projectname/workplace/trimmed
FILES=/Users/user1/projectname/workplace/raw/*.fq

for f in $FILES
do
f=${f##*/}
f=${f%.fq}

trim_galore \
"raw/$f"".fq" \
-a AGATCGGAAGAGCACACGTCT \ # change this based on adaptors used
--max_length 30 --length 16 \
--output_dir /Users/user1/projectname/workplace/trimmed/
done

```

## 4. Check the quality of trimmed samples
```{r, eval = FALSE}
## check quality of trimmed samples
checkQuality(files = "/Users/user1/projectname/workplace/trimmed/")
```

## 5. Mapping cleaned reads to the merged reference in three steps. 

### 5.1 Map cleaned reads for both multi-mapping and unique mapping. 
This step is to identify dicer-derived clusters in each sample. 

```{bash, eval = FALSE}

## Mapping part 1: Two for loops for identifying multimapped and unique. 

mkdir -p /Users/user1/projectname/workplace/alignment_multi_one
mkdir -p /Users/user1/projectname/workplace/alignment_unique_one

FILES=/Users/user1/projectname/workplace/trimmed/*_trimmed.fq

# Multimapping for alignment 1.
for f in $FILES
do
f=${f##*/}
f=${f%_trimmed*}

echo "mapping with ShortStack ... $f" >> 
/Users/user1/projectname/workplace/alignment_multi_one/stats_alignment.txt


ShortStack \
--readfile "/Users/user1/projectname/workplace/trimmed/$f""_trimmed.fq" \
--genomefile /Users/user1/projectname/workplace/reference/merge/ref_merged.fa \
--bowtie_cores 6 \
--mmap u \
--mismatches 0 \
--nohp \
--bowtie_m all \
--outdir /Users/user1/projectname/workplace/alignment_multi_one/$f >> 
/Users/user1/projectname/workplace/alignment_multi_one/stats_alignment.txt 2>&1

done


# map unique
for f in $FILES
do
f=${f##*/}
f=${f%_trimmed*}

echo "mapping with ShortStack ... $f" >>
/Users/user1/projectname/workplace/alignment_unique_one/stats_alignment.txt

ShortStack \
--readfile "/Users/user1/projectname/workplace/trimmed/$f""_trimmed.fq" \
--genomefile /Users/user1/projectname/workplace/reference/merge/ref_merged.fa \
--bowtie_cores 6 \
--mmap n \
--mismatches 0 \
--nohp \
--outdir /Users/user1/projectname/workplace/alignment_unique_one/$f >>
/Users/user1/projectname/workplace/alignment_unique_one/stats_alignment.txt 2>&1

done

```


### 5.2 Create an annotation file which contains all the dicer-derived clusters 
### across all the samples. 
```{r, eval = FALSE}
## Merge identified sRNA clusters across all samples into a annotation file 

conditions <- c("TomEgg_1","TomEgg_2","TomEgg_3",
                "TomTom_1","TomTom_2", "TomTom_3")

folder <- "./workplace/alignment_multi_one/"
save_folder <- "./workplace/reference/"

identifyClusters(files = folder, 
             out = save_folder,
             samples = conditions)

```

### 5.3 Last mapping step using information on all the dicer-derived clusters. 
The identified clusters will effectively be translated
into the loci the `ShortStack` software will use for mapping. An additional step 
to reduce noise has been introduced here by setting a threshold of 5 for the 
minimum coverage. 

```{bash, eval = FALSE}
 
## Mapping part 2: Two for-loops for identifying multimapped and unique using 
# the cluster information and with a minimum coverage setting to filter noice. 

mkdir -p /Users/user1/projectname/workplace/alignment_multi_two
mkdir -p /Users/user1/projectname/workplace/alignment_unique_two

FILES=/Users/user1/projectname/workplace/trimmed/*_trimmed.fq

for f in $FILES
do
f=${f##*/}
f=${f%_trimmed*}

echo "mapping with ShortStack ... $f" >> 
/Users/user1/projectname/workplace/alignment_multi_two/stats_alignment.txt
ShortStack \
--readfile "/Users/user1/projectname/workplace/trimmed/$f""_trimmed.fq" \
--genomefile /Users/user1/projectname/workplace/reference/merge/ref_merged.fasta \
--locifile /Users/user1/projectname/workplace/reference/ClusterInfo.txt \
--bowtie_cores 6 \
--mmap u \
--mismatches 0 \
--nohp \
--bowtie_m all \
--mincov 5 \
--outdir /Users/user1/projectname/workplace/alignment_multi_two/$f >> 
/Users/user1/projectname/workplace/alignment_multi_two/stats_alignment.txt 2>&1

echo "mapping unique matches with ShortStack ... $f" >> 
/Users/user1/projectname/workplace/alignment_unique_two/stats_alignment.txt
ShortStack \
--readfile "/Users/user1/projectname/workplace/trimmed/$f""_trimmed.fq" \
--genomefile /Users/user1/projectname/workplace/reference/merge/ref_merged.fasta \
--locifile /Users/user1/projectname/workplace/reference/ClusterInfo.txt \
--bowtie_cores 6 \
--mmap n \
--mismatches 0 \
--nohp \
--mincov 5 \
--outdir /Users/user1/projectname/workplace/alignment_unique_two/$f >>
/Users/user1/projectname/workplace/alignment_unique_two/stats_alignment.txt 2>&1

done

```


## 6. Merge the Annotaion files and identify the overlap between the sRNA 
## clusters and the genomic features in the annotation file. 

```{r, eval = FALSE}
## merge the annotation files into a single annotation file 
merge_files(files = "/Users/user1/projectname/workplace/annotation/",
            out = "/Users/user1/projectname/workplace/annotation/merge/anno_merged.gff")
## Find the overlap between the identified clusters and the merged annotation file
## This will enable annotation of the sRNA to aid funcitonal analysis 

find_overlap(annotation = "/Users/user1/projectname/workplace/annotation/merge/anno_merged.gff",
             clusters = "/Users/user1/projectname/workplace/reference/ClusterInfo.gff3", 
             out = "/Users/user1/projectname/workplace/reference/overlap.bed")
```


# Analysis 
The analysis uses the `Result.txt` file created for each sample in the second 
**unique** mapping step directory, where there is one folder per sample replicate. 
Here, we show an example of how to identify mobile sRNA 
molecules at lengths of 24-nt and 21/22-nt. 

## Organise the results from the pre-processing into a data set

The `RNAimport` function required the location of results from the second 
mapping step, complete annotation of the dicer-derived cluster information and 
the genomic overlap between the clusters and reference annotation. 

In addition, to select the samples and also calculate the FPKM values, the 
function requires the sample names as represented by each results folder 
outputted by ShortStack and the total number of reads analysed. The 
total number of reads can be located in the log file in the results file of each 
sample. Please ensure that the order of the total number of reads is the same
for the order of sample names, in order to create a table. 


```{r, eval = FALSE}

# Name of samples
sample_names <- c("TomEgg_1","TomEgg_2", "TomEgg_3", 
                "TomTom_1", "TomTom_2", "TomTom_3")
# number of total reads in sample (same order as sample_names object)
read_numbers <- c(24441759,21378845, 21482356, 3951725, 3343954, 2586910)
# create table
names(read_numbers) <- sample_names

## Path to genomic overlap data file (.bed)
genomic_features <-  "./analysis/reference/overlap.bed"

## Path to results 
results_dir <-  "./analysis/alignment_unique_two/"

## Path to annotation file created in the pre-processing step, storing 
## dicer-derived cluster information. 
clusterlocations <- rtracklayer::import.gff("./analysis/reference/
                                            ClustersInfo.gff3")
## Import & organise data. 
sRNA_data <- RNAimport(results = results_dir, 
                           samples = sample_names, 
                           clusters = clusterlocations, 
                           totalNumReads = read_numbers, 
                           features = genomic_features)



```

## Define the consensus sRNA classes for each sRNA and subset. 
Each sample in the analysis has determined the class (DicerCall) of a 
dicer-derived sRNA cluster based on the most abundant small RNA size in the 
sample at a locus. It is expected that samples in the same condition define a
sRNA cluster as the same size and class. The `RNAconsensus` function is used
to define the class of a sRNA cluster based on a consensus across specific 
samples. To identify small RNA traveling from genotype A to B in a heterograft 
in comparision to a self-grafted of the B genotype, it is recommend to base 
the consensus call on the heterografted samples. This will ensure that the 
sRNA class is more accurately defined by the genotype it originated from. 

Here, we also utilise the `RNAsubset` function to separate your analysis based 
on a specific class of sRNA, based on nucelotide length (20-24 nucleotides). In 
this analysis it is focused on two groups: 24nt sRNAs and 21/22nt sRNAs.


```{r, message=FALSE}
data(sRNA_data)
##  define consensus sRNA classes. 
samples <- c("TomEgg_1", "TomEgg_2", "TomEgg_3")

sRNA_data_summary <- RNAconsensus(data = sRNA_data, 
                                 conditions = samples)
# Subset data: 24-nt sRNAs 
sRNA_24 <- RNAsubset(sRNA_data_summary, type = 24, sig = FALSE)
# Subset data: 24 21/22-nt sRNAs 
sRNA_2122 <- RNAsubset(sRNA_data_summary, type = c(21, 22), sig = FALSE)
```

## Plot distribution of RNA classes 
Plot the distribution of the consensus sRNA clusters sizes across the total 
data set. 

```{r}
consensus_plot <- RNAdistribution(data = sRNA_data_summary, 
                                  consensus = TRUE, style = "consensus")
```

## Differential expression analysis. 
Differential expression analysis can be undertaken with a range of popularly 
used tools. Here we have provided a function which provides the flexibility to 
employ either the edgeR method or the DESeq2 method. 

In the example here, the DE analysis has been undertaking using the `DESeq2` 
method, but there is also the option to choose `edgeR` instead. Simply, change 
the `method` option. Regardless of the method, it is important to list the 
conditions in the analysis in the order perceived in the input data frame. 
For instance, the example the sample information in the data set contains 
three heterografts and three selfgrafts, which are ordered from left to right in
the dataset. 

This step provides you with information on the statistical value and log-fold 
change. This is important if you look to select statistically significant sRNA 
clusters and/or plot the log-fold change as a heatmap to represent the data. 


```{r , message=FALSE}
# sample conditions. 
groups <- c("Tomato/Eggplant", "Tomato/Eggplant", "Tomato/Eggplant", 
           "Tomato/Tomato", "Tomato/Tomato", "Tomato/Tomato")


## Differential analysis: DEseq2 method
# 24-nt sRNA data-set
sRNA_24_DESeq2 <- RNAanalysis(data = sRNA_24, 
                                 group = groups,
                                 method = "DESeq2" )
# 2122-nt sRNA data-set
sRNA_24_DESeq2 <- RNAanalysis(data = sRNA_2122, 
                                 group = groups,
                                 method = "DESeq2" )

```


## Identify the potential mobile sRNA molecules

This step identified the mobile sRNA from you genotype of interest. It removes 
the sRNA which were mapped to the genotype of the destination tissue. 

If statistical significance is not important to the analysis, the differential 
expression step can be missed and the parameter `statistical` in  the `RNAmobile`
function can be set to `FALSE`. 

```{r, message=FALSE}
## Identify mobile sRNAs in each subset - keep clusters associated to the 
## tomato genome

# define control samples
controls <- c("TomTom_1","TomTom_2", "TomTom_3" )

#  in 24nt RNA database 
sRNA_24_mobile <- RNAmobile(data = sRNA_24_DESeq2, 
                                   controls = controls,
                                   id = "SL40", 
                                   task = "remove")
#  in 2122nt RNA database 
sRNA_2122_mobile <- RNAmobile(data = sRNA_24_DESeq2,
                                     controls = controls, 
                                     id = "SL40", 
                                     task = "remove")

```


## Plot heatmap of potential mobile sRNAs 

```{r,  echo=FALSE}
cap1 <- "An example heatmap to represent the potential mobile RNA 
molecules using the DESeq2 method. A) 24 Nucleotide mobile RNA. 
A) 21/22 Nucleotide mobile RNA. "
```

```{r,message=FALSE, fig.cap=cap1, fig.show="hold", out.width="50%", fig.subcap= c("A","B")}
plotHeatmap(sRNA_24_mobile)
plotHeatmap(sRNA_2122_mobile)
```

# Additional features 

The *RNAlocate* package offers several of other helpful functions to aid 
analysis. This includes a function to plot sample distance for quality control,
calculate the mean FPKM and counts across specific samples and 
also calculate the overlap between genomic features and sRNA clusters.

## Plot sample distance for quality control 

```{r}
# plot principal component analysis 
analysis_groups <- c("Tomato/Eggplant", "Tomato/Eggplant", "Tomato/Eggplant",
           "Tomato/Tomato",   "Tomato/Tomato", "Tomato/Tomato")
plotSamplePCA(data = sRNA_data, group = analysis_groups)

# plot heatmap 
PCA_p1 <- plotSampleDistance(sRNA_data)
```

## Calculate FPKM and Count means for specific samples
```{r, eval = FALSE}
# calculate mean FPKM and mean Counts for heterograft samples
selected_samples <- c("TomEgg_1", "TomEgg_2", "TomEgg_3")
means <- RNAmean(data = sRNA_data, conditions = selected_samples)

```


## Calculate distribution of sRNA clusters across genomic features. 

```{r, eval = FALSE}
# matrix containing percentage of sRNA clusters associated to different genomic 
# features
dis_features <- RNAfeatures(data = sRNA_data, 
                            annotation = "./annotation/eggplant_genome.gff3",
                            repeats = "./annotation/eggplant_genome_repeats.gff3")
```


# Session information
```{r}
sessionInfo()
```

