% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/RNAdicercall.R
\name{RNAdicercall}
\alias{RNAdicercall}
\title{Define the sRNA dicer consensus for each dicer-derived sRNA cluster}
\usage{
RNAdicercall(
  data,
  conditions = NULL,
  ties.method = NULL,
  tidy = FALSE,
  chimeric = FALSE,
  controls = NULL,
  genome.ID = NULL
)
}
\arguments{
\item{data}{data.frame; originally generated by \code{\link[=RNAimport]{RNAimport()}}.}

\item{conditions}{character; vector containing sample replicate names. When
supplied, the data from the named replicates will be the only ones used to
calculate the dicer-derived dicercall consensus for each sRNA cluster. Each
string should represent a sample name present in the dataframe supplied to
the \code{data} argument.}

\item{ties.method}{character; string specifying how ties are handled, choose
either "exclude" or "random". When using \code{random}, if there is a tie one of
the classes will be choose at random. While, when using \code{exclude} if there is
a tie the class is set to undefined, however, if there is a tie between a
undefined and a known class, the known class takes president (eg 3x24-nt and
3xN-nt, then it will be classed as 24nt). Default setting
\code{ties.method="exclude"}.}

\item{tidy}{logical; tidy-up data by removing sRNA clusters with an unknown
or unclassified result. Default setting \code{tidy=TRUE}, removes excess
background noise.}

\item{chimeric}{logical; state whether system is chimeric: contains multiple
genomes/genotypes.}

\item{controls}{character; vector of control condition sample names.}

\item{genome.ID}{character; chromosome identifier of foreign genome in
chimeric system.}
}
\value{
A data frame containing all existing columns in the input data object,
plus, two additional columns of data:

The first column, \code{DicerCounts} contains the number of replicates which
contributed to defining the dicer-derived sRNA class. This can be
utilised within the \code{RNAmobile} function as a threshold parameter.
While, utilising \code{exclude} ties methods, the \code{DicerCounts} value for a tie
will be 0 as no consensus classification was concluded. While, if the majority
of replicates contributed unclassified for a cluster, the \code{DicerCounts} value
represents the number of replicates which which contributed to the
unclassified consensus in \code{DicerConsensus}.

The second, labeled \code{DicerConsensus} states the consensus sRNA class between
nucleotides in length or "N" if unclassified.
}
\description{
Using the data, the function uses the supplied dataframe and
adds an additional column stating the consensus sRNA class for each
dicer-derived cluster.
}
\details{
The function calculates the consensus sRNA class. Changes in parameter
settings will yield varying results.

When working with a chimeric system, for example interspecific grafting,
mapping errors can easily be recognised and eliminated. Here, these can be
eliminated by supplying some extra parameter information. State
\code{chimeric=TRUE} and supply the chromosome identifier of the foreign genome
(ie. not the tissue sample genotype, but the genotype from which any
potential mobile molecules could be traveling from) to the \code{genome.ID}
parameter & the control condition samples names to the \code{controls} parameter.

When ties.method = "random", as per default, ties are broken at random.
In this case, the determination of a tie assumes that the entries are
probabilities: there is a relative tolerance of 1e-5, relative to the
largest (in magnitude, omitting infinity) entry in the row.

When ties.method = "exclude", ties between sRNA classification are ruled as
unclassified ("N").

To remove excess data noise, \code{tidy=TRUE} can be used to removed unclassified
("N") sRNA clusters, resulting in a reduced dataset size.
}
\examples{
 # load data 
 data("sRNA_data")

# define consensus sRNA classes.
conditions <- c("heterograft_1", "heterograft_2", "heterograft_3")

# Run function to define sRNA class for each cluster.
sRNA_data_consensus <- RNAdicercall(data = sRNA_data,
                                  conditions = conditions,
                                  tidy=TRUE)

}
